<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Régression logistique : fichier ‘spam’</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="include\style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Analyses Statistiques</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    MORE
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="reg_log_spam.html">Regression logistique</a>
    </li>
    <li>
      <a href="knn.html">KNN</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">Régression logistique : fichier ‘spam’</h1>

</div>


<div id="les-donnees" class="section level2">
<h2><strong>Les données</strong></h2>
<div class="jumbotron">
<strong>Prédire un mail comme étant un “spam” ?</strong><br /> source : <br /> <a href="http://archive.ics.uci.edu/ml/index.php" class="uri">http://archive.ics.uci.edu/ml/index.php</a> <br /> <a href="http://archive.ics.uci.edu/ml/machine-learning-databases/spambase/" class="uri">http://archive.ics.uci.edu/ml/machine-learning-databases/spambase/</a> <br /> Extrait des informations du fichier : <br />
<ul>
<li>
Creators: Mark Hopkins, Erik Reeber, George Forman, Jaap Suermondt Hewlett-Packard Labs, 1501 Page Mill Rd., Palo Alto, CA 94304
<li>
Donor: George Forman (gforman at nospam hpl.hp.com) 650-857-7835
<li>
Generated: June-July 1999<br />

</ul>
</div>
<p><strong>Informations principales sur la structure de données :</strong></p>
<pre><code>Attribute Information:
#   The last column of &#39;spambase.data&#39; denotes whether the e-mail was 
# considered spam (1) or not (0), i.e. unsolicited commercial e-mail.  
# Most of the attributes indicate whether a particular word or
# character was frequently occuring in the e-mail.  The run-length
# attributes (55-57) measure the length of sequences of consecutive 
# capital letters.  For the statistical measures of each attribute, 
# see the end of this file.  Here are the definitions of the attributes:
#   
#   48 continuous real [0,100] attributes of type word_freq_WORD 
# = percentage of words in the e-mail that match WORD,
# i.e. 100 * (number of times the WORD appears in the e-mail) / 
#   total number of words in e-mail.  A &quot;word&quot; in this case is any 
# string of alphanumeric characters bounded by non-alphanumeric 
# characters or end-of-string.
# 
# 6 continuous real [0,100] attributes of type char_freq_CHAR
# = percentage of characters in the e-mail that match CHAR,
# i.e. 100 * (number of CHAR occurences) / total characters in e-mail
# 
# 1 continuous real [1,...] attribute of type capital_run_length_average
# = average length of uninterrupted sequences of capital letters
# 
# 1 continuous integer [1,...] attribute of type capital_run_length_longest
# = length of longest uninterrupted sequence of capital letters
# 
# 1 continuous integer [1,...] attribute of type capital_run_length_total
# = sum of length of uninterrupted sequences of capital letters
# = total number of capital letters in the e-mail
# 
# 1 nominal {0,1} class attribute of type spam
# = denotes whether the e-mail was considered spam (1) or not (0), 
# i.e. unsolicited commercial e-mail.  
# 
# 
# 8. Missing Attribute Values: None
# 
# 9. Class Distribution:
#   Spam      1813  (39.4%)
# Non-Spam  2788  (60.6%)</code></pre>
<p>Pour résumer, le fichier se compose de 54 colonnes reprsentants des fréquences d’apparation d’un mot (“wf_hp” pour le mot “hp”) ou la fréquence d’un caractère spécial (“cf_dollar” pour le caractère “$”). Enfin nous avons 3 colonnes liées au caractères en majuscules et la variable réponse (spam “1”, non spam “0”).</p>
</div>
<div id="analyse-descriptive" class="section level2">
<h2><strong>Analyse descriptive</strong></h2>
<p><strong>Proportion Mail/Spam :</strong></p>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-2-1.png" width="672" /></p>
<p><strong>Moyenne des frequences des mots/caracteres par type de mail spam/non spam :</strong> <img src="reg_log_spam_files/figure-html/unnamed-chunk-3-1.png" width="672" /></p>
<div class="commentaire">
<p>On peut constater que le fichier est composé majoritairement d’emails (“non spam”, 61%)<br /> On note également l’apparition d’un caractère “!” dans les mails de type “spam”</p>
</div>
<p><br /><br /></p>
</div>
<div id="partie-modelisation" class="section level2">
<h2><strong>Partie modélisation</strong></h2>
<div id="presentation-des-notations-et-rappels-theoriques" class="section level3">
<h3>Présentation des notations et rappels théoriques</h3>
<p><b><u>Notations :</u></b></p>
<p><span class="math inline">\(X=(1,X_{1},...,X_{p})&#39;\)</span>, vecteur aléatoire de dimension <span class="math inline">\(p+1\)</span>.<br /> Les marginales <span class="math inline">\(X_{j}\)</span> sont les variables explicatives.<br /> Soit <span class="math inline">\(x=(1,x_{1},...,x_{p})&#39;\)</span>, une réalisation de <span class="math inline">\(X\)</span>.<br /> <span class="math inline">\(Y\)</span> variable à expliquer (univariée).<br /> <span class="math inline">\((X_{1},Y_{1}),...,(X_{n},Y_{n})\)</span> un échantillon aléatoire (iid et de même loi que le couple <span class="math inline">\((X,Y)\)</span>) tel que <span class="math inline">\(X_{i}=(1,X_{i1},...,X_{ip})&#39;\)</span>.<br /> <span class="math inline">\((x_{1},y_{1}),...,(x_{n},y_{n})\)</span> une réalisation de <span class="math inline">\((X_{1},Y_{1}),...,(X_{n},Y_{n})\)</span>.<br /> <span class="math inline">\(X\)</span> matrice des observations :<br />  <span class="math inline">\(\begin{matrix} 1 &amp; x_{11} \cdots &amp; x_{1p} \\ \vdots &amp; &amp; \vdots \\ 1 &amp; x_{n1}\cdots &amp; x_{np} \end{matrix}\)</span></p>
<p><br /></p>
<p><b><u>Rappels sur le modèle linéaire :</u></b></p>
<p>On chercher à expliquer une variable <span class="math inline">\(Y\)</span> par <span class="math inline">\(p\)</span> variables <span class="math inline">\(X=(1,X_{1},...,X_{p})&#39;\)</span>. Le but est de modéliser la dépendance de la variable réponse <span class="math inline">\(Y\)</span> sur les variables explicatives <span class="math inline">\(X_{1},...,X_{p}\)</span>.<br /></p>
<p><b><u>Les aspects de la modélisation :</u></b></p>
<ul>
<li>
La description : décrire la relation entre <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span>
<li>
L’évaluation : les contributions relatives de chaque prédicteur pour expliquer <span class="math inline">\(Y\)</span>
<li>
La prédiction : prévoir la valeur de <span class="math inline">\(Y\)</span> pour les nouvelles valeurs de <span class="math inline">\(X\)</span><br />

</ul>
<p><b><u>Le modèle linéaire s’écrit :</u></b></p>
<p><span class="math inline">\(Y=X&#39;\beta + \epsilon = \beta_{0}+\beta_{1}X_{1}+...+\beta_{p}X_{p}+\epsilon\)</span><br />  Avec<br /> <span class="math inline">\(\beta=(\beta_{0},\beta_{1},...,\beta_{p})&#39; \in \mathbb{R}^{p+1}\)</span> et <span class="math inline">\(\epsilon=N(0,\sigma^2)\)</span> <span class="math inline">\(Y\sim N(X&#39;\beta,\sigma^2)\)</span> (hypothèse d’homoscédasticité)<br /></p>
<p>Dans le cas d’une variable <span class="math inline">\(Y\)</span> <strong>qualitative</strong> (état, sexe, couleur), l’enjeu est d’expliquer l’appartenance d’un individu à un groupe à partir des <span class="math inline">\(p\)</span> variables (on parlera de discrimination).<br /> <br /> ⚠⚠⚠<br /> Contrairement à la régression linéaire, ici on ne peut pas modéliser directement une relation linéaire entre <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span>.<br /> ⚠⚠⚠<br /></p>
<p>On va s’interesser aux probabilités <span class="math inline">\(P(Y=g_{k}|X=x)\)</span>. Pour simplifier, prenons le cas ou <span class="math inline">\(Y\)</span> est binaire (0 ou 1). De fait, si l’on connait <span class="math inline">\(P(Y=1|X=x)\)</span> on connait <span class="math inline">\(P(Y=0|X=x)\)</span>.<br /> On peut envisager une relation de la forme :<br />  <span class="math inline">\(p_{\beta}(x)=\beta_{0}+\beta_{1}X_{1}+...+\beta_{p}X_{p}+\epsilon=X&#39;\beta+\epsilon\)</span><br /> <br /> Ici l’hypothèse d’homoscedasticité des résidus est non vérifiée. En effet, la variance de <span class="math inline">\(Y|X = p_{\beta}(x)*(1-p_{\beta}(x))\)</span> (non constante).<br /> Egalement, à ce stade nous n’avons pas de restriction sur les valeurs des <span class="math inline">\(\beta\)</span> et donc des valeurs de <span class="math inline">\(p_{\beta}(x)\)</span> <span class="math inline">\((p_{\beta}(x)\in\mathbb{R})\)</span>.<br /></p>
<p><br /></p>
</div>
<div id="application-de-la-regression-logistique" class="section level3">
<h3>Application de la régression logistique</h3>
<p>Dans notre cas, nous voulons expliquer la variable <span class="math inline">\(Y\)</span> (spam “1” ou non spam “0”) par <span class="math inline">\(p\)</span> variables explicatives <span class="math inline">\(X=(1,X_{1},...,X_{p})&#39;\)</span>.<br /> Le modèle logistique propose une modélisation de la loi de <span class="math inline">\(Y|X=x\)</span> par une loi de <strong><em>Bernouilli</em></strong> de paramètre <span class="math inline">\(p_{\beta}(x)=P_{\beta}(Y=1|X=x)\)</span> telle que :<br />  <span class="math inline">\(log(\frac{p_{\beta}(x)}{1-p_{\beta}(x)})=\beta_{0}+\beta_{1}X_{1}+...+\beta_{p}X_{p}=x&#39;\beta\)</span><br /> ou encore  <span class="math inline">\(logit \space p_{\beta}(x)=x&#39;\beta\)</span><br /> <span class="math inline">\(logit\)</span> désignant la fonction bijective et dérivable de <span class="math inline">\(]0 \space 1[\)</span> dans <span class="math inline">\(\mathbb{R}:p \to log(p/1-p)\)</span><br /></p>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-4-1.png" width="480" /></p>
<p>L’égalité peut s’écrire : <br />  <span class="math inline">\(P_{\beta}(Y=1|X=x)=\frac{\mathrm{e}^{x&#39;\beta}}{1+\mathrm{e}^{x&#39;\beta}}\)</span><br />  On a <br /></p>
<p><span class="math inline">\(\left\{\begin{array}{l}\mathrm{Var_{\beta}[Y|X=x]}=P_{\beta}(Y=1|X=x)*(1-P_{\beta}(Y=1|X=x))\\\mathrm{E_{\beta}[Y|X=x]}=P_{\beta}(Y=1|X=x)\\\end{array}\right.\)</span> <br /></p>
<p>Ce qui implique que la variance n’est pas constante et varie selon <span class="math inline">\(x\)</span>. <br /> <br /> Pour une nouvelle mesure <span class="math inline">\(x\)</span> effectuée, le modèle log linéaire va donc prédire la valeur <span class="math inline">\(\mathrm{e}^{x&#39;\beta}\)</span> (<span class="math inline">\(\beta\)</span> est le paramètre à estimer).<br /><br /></p>
<div id="estimation-des-parametres-par-maximum-de-vraissemblance" class="section level4">
<h4>Estimation des paramètres par maximum de vraissemblance</h4>
<p>La vraissemblance s’écrit :<br /><br />   <span class="math inline">\(L_{n}(\beta)=\prod_{i=1}^n P_{\beta}(Y=y_{i}|X=x_{i})\)</span><br /><br />   <span class="math inline">\(L_{n}(\beta)=\prod_{i=1}^n P_{\beta}(x_{i})^{y_{i}}*(1-P_{\beta}(x_{i}))^{1-y_{i}}\)</span><br /></p>
<p>La log vraissemblance s’écrit :<br /><br />  <span class="math inline">\(\mathcal{L}_{n}(\beta)=\sum_{i=1}^n \{ y_{i}*log(P_{\beta}(x_{i}))+(1-y_{i})*log(1-P_{\beta}(x_{i})) \}\)</span><br /></p>
<p>L’estimateur du maximum de vraissemblance si il existe est solution de l’équation (équation de score):<br /><br />  <span class="math inline">\(S(\beta)= \nabla\mathcal{L}_{n}(\beta)=X&#39;(Y-P_{\beta})=0\)</span><br /></p>
<p><br /> Ces équations forment un système non linéaire en <span class="math inline">\(\beta\)</span>. Il faut utiliser des méthodes numériques (algorithme de convergene).<br /><br /></p>
</div>
<div id="algorithme-irls" class="section level4">
<h4>Algorithme IRLS</h4>
<p>L’algorithme IRLS (Iterative Reweighted Least Square), dit aussi <strong><em>méthode Newton-Raphson</em></strong>, permet de résoudre ces équations de score.<br /> Il existe aussi l’algorithme de score de <strong><em>Fisher</em></strong>, mais nous allons rester sur IRLS car c’est celui qui est implémenté sous R dans la fonction <strong><em>glm()</em></strong> (<em>method=“glm.fit”</em>).<br /></p>
L’algorithme procède par itération jusqu’à convergence :<br />
<ol>
<li>
choix du point départ <span class="math inline">\(\beta_{0}\)</span>
</li>
<li>
on calcule <span class="math inline">\(\beta^{k+1}\)</span> à partir de <span class="math inline">\(\beta^{k}\)</span>
</li>
</ol>
<p><span class="math inline">\(\beta^{k+1}=\beta^{k}+A^k\nabla\mathcal{L}_{n}(\beta^k)\)</span><br />   Où<br /> <span class="math inline">\(\nabla\mathcal{L}_{n}(\beta^k)\)</span> est le gradient au point <span class="math inline">\(\beta^{k}\)</span> et <span class="math inline">\(A^k=-(\nabla^2\mathcal{L}_{n}(\beta^k))^{-1}\)</span> est la matrice de “pas” (inverse du hessien au point <span class="math inline">\(\beta^{k}\)</span>). <br /></p>
<p>Ecriture matricielle : <br /><br />  <span class="math inline">\(\beta^{k+1} = \beta^{k}+(X&#39;W_{\beta^k}X)^{-1}X&#39;(Y-P_{\beta^k})\)</span><br /> Où <span class="math inline">\(W_{\beta}\)</span> est la matrice diagolane <span class="math inline">\(P_{\beta}(x_{i})*(1-P_{\beta}(x_{i}))\)</span>.<br /></p>
<p><b><u>Interprétation des coefficients <span class="math inline">\(\beta\)</span> :</u></b></p>
<p>On peut reprénsenter la fonction <span class="math inline">\(x \mapsto \frac{\mathrm{e}^{x&#39;\beta}}{1+\mathrm{e}^{x&#39;\beta}}\)</span> pour différentes valeurs de <span class="math inline">\(\beta\)</span>.<br /></p>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-5-1.png" width="672" /></p>
<p>Lorsque le <strong><em><span class="math inline">\(\beta\)</span> est faibe</em></strong> (proche de 0), on peut voir que la fonction couvre une large valeur de <span class="math inline">\(x\)</span> autour de 0.5. La <strong><em>discrimintation est difficile</em></strong>. Au contraire si le <strong><em><span class="math inline">\(\beta\)</span> est élevé</em></strong>, la zone autour de 0.5 diminue au profit des valeurs extrêmes 0 et 1, ce qui pourrait <strong><em>minimiser les erreurs de prévisions</em></strong>.<br /></p>
<p><br /> <br /> <br /></p>
</div>
</div>
</div>
<div id="partie-modelisation-rstudio" class="section level2">
<h2><strong>Partie modélisation Rstudio</strong></h2>
<p>La régression logistique sera exécutée à l’aide de la fonction <strong><em>glm {stats}</em></strong>.<br /></p>
<p>L’exécution se fera dans un premier temps sur le fichier complet afin de présenter le modèle (Utilisation d’un échantillon <strong>train/test</strong> par la suite).<br /> <br /></p>
<div id="presentation-du-modele-glm" class="section level3">
<h3>Présentation du modèle glm</h3>
<p><b><u>Le modèle :</u></b></p>
<pre class="r"><code>####
#REGRESSION LOGISTIQUE
####
 #execution du modele complet:
 modele.reg.log &lt;- glm(Don_spam$spam ~ .,
                        family = binomial(link=&quot;logit&quot;), data=Don_spam)


# Degrees of Freedom: 4600 Total (i.e. Null);  4543 Residual
# Null Deviance:        6170 
# Residual Deviance: 1816   AIC: 1932</code></pre>
<div class="commentaire">
<p>Résultat du modèle :<br /> Application du modele sur les 4601 individus et 58 colonnes (57 + constante)<br /> Le modèle nous fournit en sortie les valeurs des coefficients <span class="math inline">\(\beta\)</span> par variable.<br /> Les degrés de liberté, (n-1 pour la dimension totale et n-p-1 pour les résidus).<br /> La déviance du modèle seulement avec la constante (Null Deviance), la déviance du modèle et l’AIC.</p>
</div>
<p>Calcul de la déviance et de l’AIC d’un modèle M :<br />  <span class="math inline">\(D_{\mathcal{M}}=-2*\mathcal{L}_{n}(\beta)\)</span><br />  <span class="math inline">\(AIC(\mathcal{M})=2*p-2*\mathcal{L}_{n}(\beta)\)</span><br /></p>
<p>Revenons sur le vecteur <span class="math inline">\(\beta\)</span>, le vecteur des coefficients des descripteurs du modèle.<br /></p>
<pre class="r"><code>modele.summary&lt;-summary(modele.reg.log)

# Coefficients:
#                              Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept)                -1.569e+00  1.420e-01 -11.044  &lt; 2e-16 ***
# wf_make                    -3.895e-01  2.315e-01  -1.683 0.092388 .  
# wf_address                 -1.458e-01  6.928e-02  -2.104 0.035362 *  
# wf_all                      1.141e-01  1.103e-01   1.035 0.300759    
# wf_3d                       2.252e+00  1.507e+00   1.494 0.135168    
# wf_our                      5.624e-01  1.018e-01   5.524 3.31e-08 ***
# wf_over                     8.830e-01  2.498e-01   3.534 0.000409 ***
# wf_remove                   2.279e+00  3.328e-01   6.846 7.57e-12 ***
# ...</code></pre>
<div class="commentaire">
<p>En sortie de la commande <strong><em>summary(modele.reg.log)</em></strong>, nous avons les valeurs des coefficients et les ecarts type. Nous avons également la valeur du <strong><em>test de Wald</em></strong> avec la p-value associée.</p>
</div>
<p>Enfin, le modèle glm nous fournit les valeurs prédites/estimées <span class="math inline">\(P_{\beta}(Y=y|X=x)=\frac{\mathrm{e}^{x&#39;\beta}}{1+\mathrm{e}^{x&#39;\beta}}\)</span><br /></p>
<pre class="r"><code>p.estime&lt;-modele.reg.log$fitted.values

#  1            2            3            4            5            6            7            8 
# 6.189824e-01 9.880333e-01 9.999977e-01 7.786119e-01 7.785570e-01 6.686157e-01 7.612542e-01 6.663679e-01 </code></pre>
<div class="commentaire">
<p><strong><em>L’objet “fitted.values”</em></strong> du modèle retourne le vecteur des probabilités d’appartenir à la classe “spam” 1 ou “non spam” 0.Cela nous permettra par la suite d’établir le taux d’erreur des “mal classés” du modèle.</p>
</div>
</div>
<div id="evaluation-du-modele" class="section level3">
<h3>Evaluation du modèle</h3>
<p>Afin de mieux comprendre les sorties du modèle <em>glm</em>, je vais détailler la partie “présentation du modèle glm”. En effet, nous allons voir qu’il existe bon nombre d’indicateurs et tests permettant d’évaluer la relation entre <span class="math inline">\(Y\)</span> et <span class="math inline">\(X\)</span>.<br /></p>
<p>⚠⚠⚠<br /> La particularité du fichier de données <em>“spam”</em> est qu’il met en défaut certains tests et procédures du fait des valeurs des descripteurs (nombreuses valeurs à 0, ce qui peut provoquer des “non convergences”).<br /> ⚠⚠⚠<br /></p>
<p>Nous avons vu précedemment avec les <em>estimateurs du maximum de vraissemblance</em> et <em>l’algorithme IRLS</em> que nous obtenons un veteur <span class="math inline">\(\beta\)</span> solution de l’équation de score <span class="math inline">\(S(\beta)=0\)</span>. Le vecteur <span class="math inline">\(\beta\)</span> nous garantit une vraissemblance maximum et donc une déviance minimum pour le modèle.<br /> <br /></p>
<div id="modele-vs-modele-trivial" class="section level4">
<h4>Modèle Vs modèle trivial</h4>
<p>Dans un premier temps, il possible d’opposer la vraissemblance du modele <span class="math inline">\(L_\mathcal{M}\)</span> et celle du modèle trivial <span class="math inline">\(L_0\)</span>. Des indicateurs existent (pseudos R²) dont le R² de Mc Fadden. Cet indicateur est analogue au R² en régression multiple et s’écrit : <br /><br />  <span class="math inline">\(R^2_{MF}=1-\frac{LL_\mathcal{M}}{LL_0} \space \left\{\begin{array}{l} Min=0 \space si \space LL_\mathcal{M} = LL_0 \space(pas \space mieux \space que \space modele \space trivial)\\ Max=1 \space si \space LL_\mathcal{M}=0 \space (modele \space parfait)\\\end{array}\right.\)</span><br /></p>
<pre class="r"><code>R2.mf = 1-(modele.reg.log$deviance/modele.reg.log$null.deviance) ; R2.mf</code></pre>
<pre><code>## [1] 0.7057179</code></pre>
<div class="commentaire">
<p>On constate que le modèle “complet” (avec tous les descripteurs) se démarque déja très bien du modèle trivial.Peut-on deja conclure à une bonne discrimination du modèle ?</p>
</div>
</div>
<div id="pouvoir-discriminant-du-modele" class="section level4">
<h4>Pouvoir discriminant du modèle</h4>
<p>De façon simple, il est possible de visualiser la répartition des <span class="math inline">\(P_β\)</span> (nos estimations/prédictions).<br /></p>
<pre class="r"><code> #HISTOGRAMME GROUPE
 y &lt;- modele.reg.log$fitted.values
 y2 &lt;- Don_spam$spam
 
 yb &lt;- hist(y,plot=F)
 yc &lt;- tapply(y,y2,cut,breaks=yb$breaks)
 tab &lt;- do.call(&quot;rbind&quot;,lapply(yc,table))
 barplot(tab,beside=T,xlab=&quot;Répartition des PI&quot;,ylab=&quot;Fréquence des PI&quot;,col=rownames(tab))
 legend(&quot;top&quot;,rownames(tab),cex =0.8,fill=rownames(tab),title=&quot;Email=0 Vs Spam=1&quot;)</code></pre>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-10-1.png" width="672" /></p>
<div class="commentaire">
<p>La discrimination des individus semble bonne, la répartition des <span class="math inline">\(P_β(x_i)\)</span> en fonction de la classe des individus semble également fonctionner.</p>
</div>
<p>On peut aller un peu plus loin tout en restant dans la simplicité. Les <span class="math inline">\(P_β(x_i)\)</span> peuvent être représenter à l’aide d’un diagramme dit de fiabilité. Le diagramme de fiabilité consiste à créer des intervalles, y calculer la somme des positifs et la moyenne des scores.Dans le cas parfait, si les scores sont bien calibrés, les points sont alignés sur une droite <span class="math inline">\(y=x\)</span>.<br /></p>
<pre class="r"><code> ###Diagramme de fiabilite
 
 breaksMean=function(Piest,Y,n)  
  #la moyenne de Piest et Y sur chaque intervalle.
 { 
  h=1/n
  x=Piest
  cl=vector(&quot;numeric&quot;,length=n+1)
  means=matrix(&quot;numeric&quot;,nrow=2,ncol=n)
  #borne gauche 0
  cl[1]=0
  #calcul des bornes de classes
  for(i in 1:n) {cl[i+1]=cl[i]+h
  means[1,i]=mean(x[(x&lt;cl[i+1])&amp;(x&gt;=cl[i])])
  means[2,i]=mean(Y[(x&lt;cl[i+1])&amp;(x&gt;=cl[i])])
  }
  
  return(means)
 }
 
 var.reponse = as.numeric(as.vector.factor(Don_spam$spam))
 
 par(mfrow = c(2, 2))
 param=c(8,10,20,50)
 for(i in 1:4){
  res.fiabilite = breaksMean(modele.reg.log$fitted.values,var.reponse,param[i])
  #Diagramme de fiabilite
  plot(res.fiabilite[1,],res.fiabilite[2,],col=&quot;blue&quot;,pch=17,type=&quot;b&quot;,main=paste(&quot;Diagramme de fiabilite&quot;,dim(res.fiabilite)[2], &quot;classes&quot;) 
       ,xlab=&quot;Moyennes des scores&quot;,ylab=&quot;Moyenne des &#39;+&#39;&quot;,xlim=c(0,1),ylim=c(0,1))
  points(c(0,1),c(0,1),type=&quot;l&quot;, col=&quot;red&quot;)
 }</code></pre>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-11-1.png" width="672" /></p>
<div class="commentaire">
<p>Plus le nombre d’intervalles augmente et moins la moyenne des scores est lissée. On peut voir que globalement, pour un nombre raisonnable d’intervalles, les points suivent la bissectrice.</p>
</div>
<p>Il existe également des tests statistiques permettant de quantifier la qualité des scores <span class="math inline">\(P_β(x_i)\)</span>. Il existe le test d’Hosmer et celui de Mann-Whitney. Le test d’Hosmer mesure à l’aide d’un ki2 si les scores (probabilitées attendues) diffèrent des probabilitées théoriques. Le test de Mann-Whitney (basé sur les rangs) mesure si les distributions sont confondues à l’aide d’une loi normale.<br /></p>
<pre class="r"><code>library(ResourceSelection)
 # il faut des eff de classes superieurs a 5
 #(H0), la statistique C suit approximativement une loi du χ2 à (G − 2) (les probas attendus ne different pas des theoriques)
 
 hosm.t = hoslem.test(var.reponse, modele.reg.log$fitted.values) ; hosm.t</code></pre>
<pre><code>## 
##  Hosmer and Lemeshow goodness of fit (GOF) test
## 
## data:  var.reponse, modele.reg.log$fitted.values
## X-squared = 1725.7, df = 8, p-value &lt; 2.2e-16</code></pre>
<div class="commentaire">
<p>Si la p-value est inférieur au seuil de risque fixé (prenons 5%), les probabilités prévues diffèrent des probabilités observées. Ici on rejette H0 car la p-value est très faible (p-value &lt; 2.2e-16) et donc les scores diffèrent des scores attendus.</p>
</div>
<p>Essayons une autre fonction d’un autre pakage.<br /></p>
<pre class="r"><code>library(generalhoslem)
 logitgof(Don_spam$spam, modele.reg.log$fitted.values, g =8, ord = FALSE)</code></pre>
<pre><code>## Warning in logitgof(Don_spam$spam, modele.reg.log$fitted.values, g = 8, :
## At least one cell in the expected frequencies table is &lt; 1. Chi-square
## approximation may be incorrect.</code></pre>
<pre><code>## 
##  Hosmer and Lemeshow test (binary model)
## 
## data:  Don_spam$spam, modele.reg.log$fitted.values
## X-squared = 361.79, df = 6, p-value &lt; 2.2e-16</code></pre>
<div class="commentaire">
<p>On s’aperçoit que le test d’Hosmer ici ne fonctionne pas (valeur du ki2 également différente) du fait des valeurs des scores trop proches de 0 pour les premiers intervalles.</p>
</div>
<pre class="r"><code> hosm.t$expected</code></pre>
<pre><code>##                      
## cutyhat                      yhat0        yhat1
##   [2.22e-16,2.45e-13] 4.610000e+02 2.051634e-12
##   (2.45e-13,1.42e-05] 4.599993e+02 6.872967e-04
##   (1.42e-05,0.00373]  4.595866e+02 4.134381e-01
##   (0.00373,0.0456]    4.512903e+02 8.709656e+00
##   (0.0456,0.18]       4.069927e+02 5.300730e+01
##   (0.18,0.408]        3.373832e+02 1.226168e+02
##   (0.408,0.83]        1.654905e+02 2.945095e+02
##   (0.83,0.969]        4.140189e+01 4.185981e+02
##   (0.969,0.999]       4.725877e+00 4.552741e+02
##   (0.999,1]           1.296203e-01 4.598704e+02</code></pre>
<pre class="r"><code>wilcox.test(modele.reg.log$fitted.values ~ Don_spam$spam, alternative = c(&quot;two.sided&quot;))</code></pre>
<pre><code>## 
##  Wilcoxon rank sum test with continuity correction
## 
## data:  modele.reg.log$fitted.values by Don_spam$spam
## W = 114390, p-value &lt; 2.2e-16
## alternative hypothesis: true location shift is not equal to 0</code></pre>
<div class="commentaire">
<p>Le test de Mann-Whitney, basé sur les rangs, nous assure avec une p-value très faible (p-value &lt; 2.2e-16) le rejet de H0. En clair, les distributions sont décalées et donc les scores permettent de distinguer les positifs des négatifs. Ce qui vient renforcer la bonne impréssion faite par le diagramme de fiabilité et l’histogramme de répartition des <span class="math inline">\(P_β(x_i)\)</span>.</p>
</div>
<p>Pour conclure sur ces deux tests, ils nous permettent de vérifier des hypothèses sur les <span class="math inline">\(P_β(x_i)\)</span>.Ils ne permettent pas de conclure de la qualité de prédiction mais peuvent servir à justifier de la validité du modèle.<br /> <br /></p>
</div>
<div id="matrice-de-confusion" class="section level4">
<h4>Matrice de confusion</h4>
<p>Après avoir visualisé et analysé les scores <span class="math inline">\(P_β(x_i)\)</span>, il est temps de voir à quel point le modèle est juste ou faux. Nous allons voir à travers quelques indicateurs, la performance du modèle. <br /></p>
<pre class="r"><code># matrice confusion 
 score &lt;- ifelse(predict(modele.reg.log,Don_spam,type=&quot;response&quot;) &gt;.5, &quot;spam&quot;,&quot;mail&quot;)
 
 confusion.mat = table(Don_spam$spam, score)  

 fauxneg = confusion.mat[2,1]
 fauxpos = confusion.mat[1,2]
 vraisneg = confusion.mat[1,1]
 vraispos = confusion.mat[2,2]
 txerr = (fauxneg+fauxpos) / dim(Don_spam)[1] 
 sensibilite &lt;- vraispos / (vraispos + fauxneg)   
 precision &lt;- vraispos / (vraispos + fauxpos) 
 specificite &lt;- vraisneg / (vraisneg + fauxpos)  
  
 confusion.mat</code></pre>
<pre><code>##    score
##     mail spam
##   0 2666  122
##   1  194 1619</code></pre>
<pre class="r"><code> data.frame(txerr,sensibilite, precision, specificite)</code></pre>
<pre><code>##        txerr sensibilite precision specificite
## 1 0.06868072    0.892995 0.9299253    0.956241</code></pre>
<div class="commentaire">
La matrice de confusion permet d’avoir un “état” du modèle à travers quelques indicateurs :<br />
<ul>
<li>
la sensibilité ou le rappel nous indique la capacité à trouver les vrais positifs.
<li>
la précision est la proportion de vrais positifs parmis les positifs.
<li>
la spécificité est la proportion de négatifs detectés.
<li>
le taux d’erreur global est l’ensemble des mals classés.
</ul>
<p>Pour ce modèle, comprenant tous les descripteurs, nous obtenons un taux d’erreur legerement inférieur à 7% (soit <strong><em>moins de 7% de mals classés</em></strong>).</p>
</div>
</div>
<div id="courbe-roc" class="section level4">
<h4>Courbe ROC</h4>
<p>La courbe ROC représente la sensibilité (taux de vrais positifs) en fonction de la spécificité (taux de faux positifs) quand on fait varier le seuil s (les valeurs des scores). Dans le meilleur des cas (classifieur parfait), la courbe passe par les points (0, 0) à (0, 1) à (1, 1). Si le classifieur s’avère pas mieux que de l’aléatoire, les points sont une bissectrice (0, 0) à (1, 1).<br /></p>
<pre class="r"><code> library(ROCR)
 pred=prediction(modele.reg.log$fitted.values,Don_spam$spam)
 perf=performance(pred,&quot;tpr&quot;, &quot;fpr&quot;)
 
 auc_ROCR &lt;- performance(pred, measure = &quot;auc&quot;)
 auc_ROCR &lt;- round(auc_ROCR@y.values[[1]],3) 
 
 plot(perf,colorize = TRUE) </code></pre>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-19-1.png" width="672" /></p>
<div class="commentaire">
<p>Pour cet exemple, la courbe ROC décrit un classifieur presque parfait (AUC=0.977), n’oublions pas que nous utilisons le même fichier pour l’apprentissage et le test. Nous sommes dans un cas de surapprentissage.</p>
</div>
</div>
<div id="tests-des-coefficients" class="section level4">
<h4>Tests des coéfficients</h4>
<p>Maintenant que nous avons évalué le modèle dans sa globlité, revenons sur le comportement asymptotique de l’estimateur du maximum de vraisemblance <span class="math inline">\(\hat \beta\)</span>. <br /></p>
<p><b><u>Loi asymptotique :</u></b></p>
<p>  <span class="math inline">\(\sqrt n(\hat \beta-\beta)\xrightarrow{{\mathcal{L}}}N(0, \mathcal{I(\beta)^{-1}})\)</span><br /></p>
<p>  <span class="math inline">\(\mathcal{I}(\beta)\)</span> la marice d’information de Fisher au point <span class="math inline">\(\beta\)</span>.<br /></p>
<p>On en déduit : <br /></p>
<p> <span class="math inline">\((\hat \beta-\beta)&#39;n\mathcal{I(\beta)^{-1}}(\hat \beta-\beta)\xrightarrow{{\mathcal{L}}}\chi^2_{p+1}\)</span></p>
<p>Par convergence (<span class="math inline">\(\hat\beta\)</span> converge faiblement vers <span class="math inline">\(\beta\)</span>) de l’estimateur, on peut écrire :<br /></p>
<p> <span class="math inline">\((\hat \beta-\beta)&#39;\hat\Sigma^{-1}(\hat \beta-\beta)\xrightarrow{{\mathcal{L}}}\chi^2_{p+1}\)</span> <br /></p>
<p>avec <span class="math inline">\(\hat\Sigma^{-1}=(X&#39;W_\hat\beta X)^{-1}\)</span> inverse de la matrice hessienne. <br /></p>
<p>  Où <span class="math inline">\(W_{\hat \beta}\)</span> est la matrice diagolane <span class="math inline">\(P_{\beta}(x_{i})*(1-P_{\beta}(x_{i}))\)</span> <br /></p>
<ul>
<li>
Le test de Wald.
<li>
Le test du rapport de vraissemblance (ou déviance).
<li>
Le test du score.
</ul>
<p>On formule les hypothèses : <br /></p>
<p>  <span class="math inline">\(H_0:\beta_{j1}=\beta_{j2}=...=\beta_{jq}=0 \space contre \space H_1:\exists k \in \{1,2,...,q\}:\beta_{jk}\neq 0\)</span></p>
<p><b><u>Test de Wald :</u></b> <br /></p>
<p>On note <span class="math inline">\(\beta_{0,...,q-1}\)</span> le vecteur des q premières composantes de <span class="math inline">\(\beta\)</span>. <br /> Sous <span class="math inline">\(H_0\)</span>, on a :</p>
<p>  <span class="math inline">\(\beta&#39;_{0,...,q-1} \hat\Sigma^{-1}_{0,...,q-1}\beta_{0,...,q-1}\xrightarrow{{\mathcal{L}}}\chi^2_q\)</span></p>
<p><b><u>Test du rapport de vraissemblance :</u></b> <br /></p>
<p>Le test est basé sur la différence du rapport de vraissemblance entre le modèle et le modèle sous <span class="math inline">\(H_0\)</span>. <br /> Sous <span class="math inline">\(H_0\)</span>, on a :</p>
<p>  <span class="math inline">\(2(\mathcal{L}_{n}(\hat\beta)-\mathcal{L}_{n}(\hat\beta_{H_0}))\xrightarrow{{\mathcal{L}}}\chi^2_{q}\)</span></p>
<p><b><u>Test du score :</u></b> <br /></p>
<p>Le test vérifie, sous <span class="math inline">\(H_0\)</span> si la fonction de score (gradient de la log-vraisemblance) est proche de 0. <br /></p>
<p>Sous <span class="math inline">\(H_0\)</span>, on a :</p>
<p>  <span class="math inline">\(S(\hat \beta_0)&#39;\hat\Sigma^{-1}_{H_0}S(\hat \beta_0)\xrightarrow{{\mathcal{L}}}\chi^2_{q}\)</span><br /></p>
<p><br /></p>
</div>
<div id="test-de-wald" class="section level4">
<h4>Test de Wald</h4>
<p>Le test de Wald est le test qui est implémenté dans la fonction <em>glm {stats}</em>. Contrairement aux deux autres tests, le test de Wald n’a besoin que de la matrice hessienne généré lors de l’obtention du modèle. Il n’a pas besoin de comparer des sous modèles (sous <span class="math inline">\(H_0\)</span>) et permet donc une execution plus rapide. Neammoins, le test de Wald est plus conservateur et favorise l’hypothèse nulle <span class="math inline">\(H_0\)</span>. L’estimateur repose sur des des propriétés asymptotiques et peut s’avérer peut précis sur des petits effectifs. <br /></p>
<p><b><u>Application du test de Wald :</u></b> <br /></p>
<p>L’hypothèse de test pour le modèle (un test de nullité pour chaque variable) : <br /></p>
<p><span class="math inline">\(H_0:\beta_{j}=0 \space contre \space H_1:\beta_{j}\neq 0\)</span><br /></p>
<p>Sous <span class="math inline">\(H_0\)</span>, la statistique de test s’écrit : <br /></p>
<p>  <span class="math inline">\(W(j)=\hat a&#39;(j)\hat\Sigma^{-1}_{j}\hat a(j)\xrightarrow{{\mathcal{L}}}\chi^2_{1}\)</span><br /></p>
<p>ou</p>
<p>  <span class="math inline">\(Z_j=signe(a&#39;(j))*\sqrt W_j\sim N(0,1)\)</span> (implémenté de cette manière dans <em>glm {stats}</em>).<br /></p>
<p>A partir de la matrice hessienne du modèle, vérifions les p-value : <br /></p>
<pre class="r"><code> #test de wald : 
 V=diag(modele.reg.log$fitted.values*(1-modele.reg.log$fitted.values)) #diagonale des poids
 
 const=rep(1,4601)
 X=data.matrix( data.frame(const,Don_spam[,-58]) ) 
 
 H = t(X) %*% V %*% X ;  #matrice hessienne H p*p
 
 inverse.h = solve(H) 
 
 modele.reg.log$coefficients[1:4]</code></pre>
<pre><code>## (Intercept)     wf_make  wf_address      wf_all 
##  -1.5686144  -0.3895185  -0.1457768   0.1141402</code></pre>
<pre class="r"><code> #prenons wf_make wf_address wf_all 
 
 coef=modele.reg.log$coefficients[2:4] 
 var.cov=inverse.h[2:4,2:4]
 
 z.vect=(coef^2)/diag(var.cov)
 
 pval.wald=c()
 #resultat du test khi2
 for(i in 1:length(coef)){
  pval.wald[i] = 1- pchisq(z.vect[i],1)
 }
 
 #R est implémenté avec le test sur N(0,1)
 z.vect=abs(coef/sqrt(diag(var.cov)))
 
 pval.norm=c()
 #resultat du test N(0,1)
 for(i in 1:length(coef)){
  pval.norm[i] = 2*(1- pnorm(z.vect[i],0,1))
 }
 
 pval.wald ; pval.norm </code></pre>
<pre><code>## [1] 0.09238803 0.03536189 0.30075971</code></pre>
<pre><code>## [1] 0.09238803 0.03536189 0.30075971</code></pre>
<pre class="r"><code> summary(modele.reg.log)[[&quot;coefficients&quot;]][,4][2:4]</code></pre>
<pre><code>##    wf_make wf_address     wf_all 
## 0.09238799 0.03536157 0.30075945</code></pre>
<div class="commentaire">
<p>Nous retrouvons bien à partir de la matrice hessienne du modèle les p-value pour les variables <em>wf_make wf_address wf_all</em> avec un test du <span class="math inline">\(\chi^2\)</span> ou <span class="math inline">\(N(0,1)\)</span>. Avec un seuil à 5%, seule <em>wf_address</em> serait retenue et signifiative.</p>
</div>
</div>
<div id="distance-de-cook" class="section level4">
<h4>Distance de Cook</h4>
<p>Cette partie résumera les notions de résidus, points leviers et points influents. En effet, nous avons vu precedemment quels étaient les descripteurs les plus significatifs. Interessons nous maintenant à l’analyse des individus. <br /></p>
<p>Par simplicité d’écriture, nous noterons <span class="math inline">\(p_i=p_\beta(x_i)\)</span> <br /></p>
<p>C’est à travers la notion de <em>résidus</em> que l’analyse des individus peut se faire. Il existe plusieurs sortes de résidus, le plus simple étant <span class="math inline">\(Y-\hat p_i\)</span> (résidus bruts). Concernant la distance de Cook, nous aurons besoin d’utiliser les <em>résidus de Pearson</em>. <br /></p>
<p><b><u>Résidus de Pearson :</u></b> <br /></p>
<p>  <span class="math inline">\(RP_i=\frac{Y_i-\hat p_i}{\sqrt{\hat p_i(1-\hat p_i)}}\)</span> <br /></p>
<p><span class="math inline">\(RP_i\)</span> peut prendre des valeurs négatives élevées dans le cas de faux positifs et des valeurs positives élevées dans le cas de faux négatifs.</p>
<pre class="r"><code>library(ggplot2)
 modele.influence=influence(modele.reg.log)

 pi=modele.reg.log$fitted.values
 pear.res=modele.influence$pear.res
 
  ggplot(Don_spam, aes(x=pi, y=pear.res, color=score) ) + 
   geom_point(size = 2,   aes(shape = Don_spam$spam))+ylim(-10, 10) + 
   geom_hline(yintercept=c(-2,2), linetype=&quot;dashed&quot;, color = &quot;red&quot;) +
   ggtitle(&quot;Résidus de Pearson&quot;) + 
   theme(plot.title = element_text(hjust = 0.5))</code></pre>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<div class="commentaire">
<p>On constate bien les valeurs extrêmes des <span class="math inline">\(RP_i\)</span>, pour les faux négatifs (<span class="math inline">\(p_i\)</span> faibles pour <span class="math inline">\(Y=1\)</span>) et les faux positifs (<span class="math inline">\(p_i\)</span> fortes pour <span class="math inline">\(Y=0\)</span>).</p>
</div>
<p><b><u>Points leviers :</u></b> <br /></p>
<p>Le levier d’une obervation <span class="math inline">\(x_i\)</span> compare l’écart entre l’observation et les autres observations. Cette mesure permet de détecter un point comme étant atypique. La mesure du levier est défini à partir de la <em>hat matrice</em> ou <em>matrice de projection</em>. <br /></p>
<p>  Matrice de projection :<br /></p>
<p>  <span class="math inline">\(H=X(X&#39;W_\hat\beta X)^{-1})X&#39;W_\hat\beta\)</span><br /></p>
<p>Où <span class="math inline">\(W_{\beta}\)</span> est la matrice diagolane <span class="math inline">\(P_{\beta}(x_{i})*(1-P_{\beta}(x_{i}))\)</span>.<br /></p>
<p>Pour une observation <span class="math inline">\(x_i\)</span>, le levier est lu sur la diagonale (<span class="math inline">\(H_{ii}\)</span>).Le levier mesure également l’influence globale d’un point sur la prédiction des valeurs <span class="math inline">\(\hat p_i\)</span>. Cette influence est l’influence globale du point <span class="math inline">\(x_i\)</span> sur la prédiction des valeurs de tout autre point <span class="math inline">\(x&#39;_i\)</span>. <br /></p>
<p><b><u>Points influents :</u></b> <br /></p>
<p>Un point est dit influent si il influe sur la valeur des coefficients <span class="math inline">\(\beta\)</span>. Cette mesure est possible à condition de calculer la distance entre un coefficient estimé avec toutes les observations et un coefficient mesuré avec toutes les observations sauf une. Une mesure courante de cette influence est <strong><em>la distance de Cook</em></strong>.<br /></p>
<p> La distance de Cook pour un individu s’écrit : <br /></p>
<p>  <span class="math inline">\(D_i=\frac{1}{p}(\hat \beta_i - \hat \beta)&#39;X&#39;W_{\hat \beta}X(\hat \beta_i - \hat \beta)\approx \frac{rp^2_i*H_{ii}}{p(1-H_{ii})}\)</span><br /></p>
<p>Avec</p>
<p>  <span class="math inline">\(p=\sum_iH_{ii}\)</span> et <span class="math inline">\(rp_i^2\)</span> le résidus de Pearson au carré.<br /></p>
<p>Dans la première partie du calcul de la distance de Cook, il nous faut calculer n sous modèles. Ce n’est pas très bon en terme d’optimisation et c’est pour cela que le <em>levier</em> intervient. <br /></p>
<p>Il existe un seuil, qui s’écrit :<br /></p>
<p>  <span class="math inline">\(D_i&gt;\frac{4}{n}\)</span> avec <span class="math inline">\(n\)</span> le nombre d’observations.<br /></p>
<pre class="r"><code> p=sum(modele.influence$hat)
 seuil.cook = 4 / (dim(Don_spam)[1] - p)  #0.0008804755 
 individus.spam = rownames(Don_spam)

 library(gridExtra)
 
 x=1:4601 ; y.cook=as.vector(cooks.distance(modele.reg.log)) ; classe=Don_spam$spam
 
 gg.cook = ggplot(Don_spam, aes(x=x, y=y.cook, fill = classe, colour=classe) ) + 
  geom_bar(stat = &quot;identity&quot;) + 
  geom_text( aes(label = ifelse(as.vector(cooks.distance(modele.reg.log)) &gt; 50*seuil.cook, individus.spam, &quot;&quot;))) + 
  geom_hline(yintercept=seuil.cook, linetype=&quot;dashed&quot;, color = &quot;red&quot;) +
  geom_text(aes( 0, seuil.cook, label = round(seuil.cook,digits=3), vjust = -1), size = 4)+
  ggtitle(&quot;Di de Cook gobal&quot;) + 
  theme(plot.title = element_text(hjust = 0.5))#pb d&#39;echelle sans ylim
 
 #remise à l&#39;échelle
 
 gg.cook.detail = ggplot(Don_spam, aes(x=x, y=y.cook, fill = classe, colour=classe) ) + 
  geom_bar(stat = &quot;identity&quot;) + 
  geom_text( aes(label = ifelse(as.vector(cooks.distance(modele.reg.log)) &gt; 50*seuil.cook, individus.spam, &quot;&quot;))) + 
  geom_hline(yintercept=seuil.cook, linetype=&quot;dashed&quot;, color = &quot;red&quot;) +
  geom_text(aes( 0, seuil.cook, label = round(seuil.cook,digits=3), vjust = -1), size = 4) + 
  coord_cartesian(ylim=c(0,0.009))+
  ggtitle(&quot;Di de Cook détail&quot;) + 
  theme(plot.title = element_text(hjust = 0.5))#pb d&#39;echelle sans ylim
  
 grid.arrange(gg.cook, gg.cook.detail, ncol=2, nrow = 1)</code></pre>
<p><img src="reg_log_spam_files/figure-html/unnamed-chunk-22-1.png" width="960" /></p>
<pre class="r"><code> #comptage du nombre d&#39;individus hors seuil 
 hors.seuil.cook = y.cook[which(y.cook &gt; seuil.cook)] #valeurs decroissantes des individus leviers
 length(hors.seuil.cook) #209 individus </code></pre>
<pre><code>## [1] 209</code></pre>
<div class="commentaire">
<p>Sur le graphique de gauche, le seuil parait infime, mais c’est parce que nous avons des valeurs extremes du <span class="math inline">\(D_i\)</span> de Cook. Le graphique de droite, avec une échelle ajustée, permet de voir qu’il y a de nombreux individus hors seuils. Cependant cela ne représente que 209 individus, soit 4.5% des individus au total.</p>
</div>
<p>A l’issue des mesures des distances de Cook, il est facile de constater qu’il est possible d’améliorer notre qualité de prédiction globale (les mals classés). Dans notre cas, nous n’utilisons pour l’instant pas de donnée test à proprement parlé et donc l’amélioration entre la prédiction du modèle de départ et un nouveau modèle sans nos “individus influents” est flagrante. Je rappelle que nous sommes pour l’instant volontairement dans un cas de surapprentissage.<br /></p>
<p>Cette partie “Evaluation du modèle” est terminée, maintenant que nous connaissons mieux la nature du modèle de régression logistique, nous allons pouvoir appliquer des données “test” à notre modèle.<br /></p>
<p><br /></p>
</div>
</div>
<div id="application-sur-echantillon-test" class="section level3">
<h3>Application sur échantillon TEST</h3>
<p>Cette partie est consacrée à la <strong><em>prédiction</em></strong>, pour cela nous allons créer un échantillon d’apprentissage et un échantillon test(individus à prédire). Pour rappel le fichier “spam” est composé de 4601 individus et 57 descripteurs ainsi que la variable classifiante binaire (“spam” : 1 “mail” : 0).<br /></p>
<p>Dans cette partie, nous allons uniquement nous concentrer sur le “taux d’erreur global” (les mals classés fauxpos+fauxneg/n). Egalment cette partie aura pour objectif de comparer le taux d’erreur d’un modèle complet (toutes les variables), d’un modèle avec sélection automatique de variables (<em>stepAic</em>) et d’un modèle sans les individus “hors seuils de Cook”. <br /></p>
<p>Nous allons répeter l’expérience et génerer 100 échantillons d’apprentissage et 100 échantillons test. A chaque itération, les individus servant à costruire l’échantillon d’apprentissage ne se retrouve pas dans l’échantillon test et inversement.<br /></p>
<p>La procédure <em>stepAIC {MASS}</em> étant longue à éxecuter, l’expérience se fera sur 10 éssais.<br /></p>
<p><b><u>Modèle complet :</u></b> <br /></p>
<p>Création d’un modèle à partir de tous les descripteurs et application sur échantillon test.<br /></p>
<p><b><u>Modèle hors seuils de Cook :</u></b> <br /></p>
<p>C’est à partir du modèle complet qu’il est possible de calculer les <span class="math inline">\(D_i\)</span> de Cook pour ensuite enlever les individus hors seuils (<span class="math inline">\(D_i&gt;\frac{4}{n}\)</span>). Nous appliquons ensuite l’échantillon test sur ce modèle privé des individus hors seuils.<br /></p>
<p><b><u>Modèle stepAic :</u></b> <br /></p>
<p>Tout d’abord la procédure <em>stepAIC {MASS}</em> permet, de façon automatique, de sélectionner les descripteurs du modèle. C’est également à partir des résultats d’un premier modèle (objet <em>glm()</em> comme paramètre) que la procedure stepAic peut être utilisée. Pour résumer, la procédure stepAic utilise une méthode de sélection de variables (ici de type “both”) et cherche à minimiser l’AIC du modèle. En sortie nous avons donc un modèle de type <em>glm</em>, comprenant uniquement les descripteurs minimisant le critère AIC (en général <span class="math inline">\(p_{aic}&lt;p\)</span>, p descripteurs).</p>
<p><b><u>Comportements moyens des modèles :</u></b> <br /></p>
<pre class="r"><code>#set.seed() permet d&#39;avoir des echantillons reproductibles 
 #ici nous allons faire 100 echantillons aleatoires train/test avec un seed pour chaque itération 

#initialisation des variables avant bouclage
index &lt;- 1:nrow(Don_spam)
res.prop.train.spam=c()
res.prop.test.spam=c()
deviance.train=c()
aic.train=c()
tx_err.train=c()
tx_err.test=c()
deviance.train.cook = c()
aic.train.cook = c()
tx_err.train.cook = c()
tx_err.test.cook =c()
deviance.train.stepaic =c()
aic.train.stepaic =c()
tx_err.train.stepaic =c()
tx_err.test.stepaic =c()

######
####BOUCLAGE
######

for(i in 1:100){
 #initialisation du seed 
 set.seed(1423+i)

 #generation de l&#39;echantillon TRAIN
  #rappel proportion au global &quot;email 61%&quot; &quot;spam 39%&quot;
 
  trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
  DATASET.train &lt;- Don_spam[trainIndex, ]
  
  #proportion de spam % 
  res.prop.train.spam[i] =  round( (length(DATASET.train$spam[which(DATASET.train$spam==1)]) 
                                    /nrow(DATASET.train)) * 100,2)
  
 #generation de l&#39;echantillon TEST
  DATASET.test &lt;- Don_spam[-trainIndex, ]
  res.prop.test.spam[i] =  round( (length(DATASET.test$spam[which(DATASET.test$spam==1)]) 
                                   /nrow(DATASET.test)) * 100,2)
  
 
 #####
 #REGRESSION SUR TOUTES LES VARIABLES
 #####
 
 ##TRAIN
  modele.boucle.tot.train = glm(DATASET.train$spam ~ .,
                          family = binomial(link=&quot;logit&quot;), data=DATASET.train)
  
  # summary(modele.boucle.tot.train) 
  # 
  # #deviance et aic : AIC(M) = −2Ln(M) + 2p (p parametres sans la constante)
  # modele.boucle.tot.train$deviance ; modele.boucle.tot.train$aic ; modele.boucle.tot.train$deviance + (2*dim(DATASET.train)[2])
  
  deviance.train[i] = modele.boucle.tot.train$deviance
  aic.train[i] = modele.boucle.tot.train$aic
  
  pred.train = ifelse(modele.boucle.tot.train$fitted.values &gt;.5, 1,0) 
  #cbind(modele.boucle.tot.train$fitted.values, pred.train) pour controle
  confusion.mat.boucle.tot.train = table(DATASET.train$spam, pred.train)
  
  tx_err.train[i] = (( confusion.mat.boucle.tot.train[1,2] + 
                        confusion.mat.boucle.tot.train[2,1] ) / 
                         dim(DATASET.train)[1] )*100 
  
 
 ## Prediction sur TEST
  pred.test = ifelse(predict(modele.boucle.tot.train,DATASET.test,type=&quot;response&quot;) &gt;.5, 1,0)
 #cbind(predict(modele.boucle.tot.train,DATASET.test,type=&quot;response&quot;), pred.test) pour controle
 
  confusion.mat.boucle.tot.test = table(DATASET.test$spam, pred.test)
  
  tx_err.test[i] = (( confusion.mat.boucle.tot.test[1,2] + confusion.mat.boucle.tot.test[2,1] ) 
                    / dim(DATASET.test)[1] )*100 
  
 
 #####
 #REGRESSION SANS LES INDIVIDUS HORS SEUIL COOK
 #####
  #1 - prendre le train et enlever les hors seuil cook 
  #2- refaire une glm à partir du train sans les cook
  #3- prediction sur test 
 
 #distance de cook et seuil
  train.cook = cooks.distance(modele.boucle.tot.train)
  p.hat.train=sum(influence(modele.boucle.tot.train)$hat) #les 57 variables + 1
  seuil.cook.train = 4 / (dim(DATASET.train)[1] - p.hat.train) 
 
 ######
 #REGRESSION SANS LES HORS SEUILS COOK du TRAIN
 ######
 
 ##TRAIN
  DATASET.train.cook = DATASET.train[-which(train.cook &gt; seuil.cook.train),] #suppréssion des hors seuil pour nouveau train
 
 #dim(DATASET.train) ; dim(DATASET.train.cook) pour controle
 
 #modele sur le nouveau train
  modele.boucle.tot.train.cook = glm(DATASET.train.cook$spam ~.,
                                  family = binomial(link=&quot;logit&quot;), data=DATASET.train.cook)
 
 #deviance et aic
  deviance.train.cook[i] = modele.boucle.tot.train.cook$deviance
  aic.train.cook[i] = modele.boucle.tot.train.cook$aic
 
 #note : en message warning, certaines etapes genererent des non convergences 
 
 ## INFO TRAIN
  pred.train.cook = ifelse(modele.boucle.tot.train.cook$fitted.values &gt;.5, 1,0) 
  #cbind(modele.boucle.tot.train$fitted.values, pred.train) pour controle
  confusion.mat.boucle.tot.train.cook = table(DATASET.train.cook$spam, pred.train.cook)
 
  tx_err.train.cook[i] = (( confusion.mat.boucle.tot.train.cook[1,2] 
                            + confusion.mat.boucle.tot.train.cook[2,1] ) / 
                           dim(DATASET.train.cook)[1] )*100 
 
 ## INFO TEST
  pred.test.cook = ifelse(predict(modele.boucle.tot.train.cook,
                                  DATASET.test,type=&quot;response&quot;) &gt;.5, 1,0)
  #cbind(predict(modele.boucle.tot.train.cook,DATASET.test,type=&quot;response&quot;), pred.test.cook) pour controle
  
  confusion.mat.boucle.tot.test.cook = table(DATASET.test$spam, pred.test.cook)
  
  tx_err.test.cook[i] = (( confusion.mat.boucle.tot.test.cook[1,2] + 
                            confusion.mat.boucle.tot.test.cook[2,1] ) / 
                             dim(DATASET.test)[1] )*100 
  
}#####FIN BOUCLAGE

#####
#STEP AIC
#boucle dédiée a la step aic (seulement 10 itérations)
#####

for(i in 1:10){
 
 #initialisation du seed 
 set.seed(1423+i)
 
 trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
 DATASET.train &lt;- Don_spam[trainIndex, ]
 
 #generation de l&#39;echantillon TEST
 DATASET.test &lt;- Don_spam[-trainIndex, ]
 res.prop.test.spam[i] =  round( (length(DATASET.test$spam[which(DATASET.test$spam==1)]) 
                                  /nrow(DATASET.test)) * 100,2)
 
 ####doit marcher avec un premier modele genéré par glm 
 modele.boucle.tot.train = glm(DATASET.train$spam ~ .,
                               family = binomial(link=&quot;logit&quot;), data=DATASET.train)
 
 ######
 #SELECTION AUTOMATIQUE STEP AIC
 ######
 library(MASS)
 modele.boucle.stepwise =   stepAIC(modele.boucle.tot.train,
                                    trace = TRUE, data = DATASET.train, 
                                    direction = &quot;both&quot;, steps = 1000)
 
 ##TRAIN
 #deviance et aic
 deviance.train.stepaic[i] = modele.boucle.stepwise$deviance
 aic.train.stepaic[i] = modele.boucle.stepwise$aic
 
 pred.train.stepaic = ifelse(modele.boucle.stepwise$fitted.values &gt;.5, 1,0) 
 #cbind(modele.boucle.stepwise$fitted.values, pred.train.stepaic) pour controle
 confusion.mat.boucle.train.stepaic = table(DATASET.train$spam, pred.train.stepaic)
 
 tx_err.train.stepaic[i] = (( confusion.mat.boucle.train.stepaic[1,2] + 
                               confusion.mat.boucle.train.stepaic[2,1] ) / 
                                dim(DATASET.train)[1] )*100 
 
 ##TEST
 pred.test.stepaic = ifelse(predict(modele.boucle.stepwise,
                                    DATASET.test,type=&quot;response&quot;) &gt;.5, 1,0)
 #cbind(predict(modele.boucle.tot.train.cook,DATASET.test,type=&quot;response&quot;), pred.test.cook) pour controle
 
 confusion.mat.boucle.test.stepaic = table(DATASET.test$spam, pred.test.stepaic)
 
 tx_err.test.stepaic[i] = (( confusion.mat.boucle.test.stepaic[1,2] + 
                              confusion.mat.boucle.test.stepaic[2,1] ) / 
                               dim(DATASET.test)[1] )*100 
 

}#fin boucle stepaic </code></pre>
<div class="commentaire">
<p>L’objectif est de récuperer pour chaque modèle, la déviance, l’AIC et le taux d’erreur correspondant aux mals classés. Concernant les échantillons aléatoires, ce sont les mêmes échantillons qui sont utilisés pour chaque modèle.</p>
</div>
<pre class="r"><code>#####
 #RESULTATS
 #####
 
 #regression totale 
 #partie analyse des train
 #rappel sur le fichier total spam =&gt; Residual Deviance: 1816   AIC: 1932
 #TAUX ERREUR global : 6.868072 %
 
 tab.reg.tot = rbind(summary(deviance.train, digits = 4), summary(aic.train, digits = 4), 
                     summary(tx_err.train, digits = 4), summary(tx_err.test, digits = 4),
                     summary(deviance.train.cook, digits = 4), 
                     summary(aic.train.cook, digits = 4),
                     summary(tx_err.train.cook, digits = 4), 
                     summary(tx_err.test.cook, digits = 4),
                     summary(deviance.train.stepaic, digits = 4),
                     summary(aic.train.stepaic, digits = 4), 
                     summary(tx_err.train.stepaic, digits = 4), 
                     summary(tx_err.test.stepaic, digits = 4)) 
 rownames(tab.reg.tot) = c(&quot;DEV.TRAIN&quot;, &quot;AIC.TRAIN&quot;, &quot;tx_err.train&quot;, &quot;tx_err.test&quot;,
                           &quot;deviance.train.cook&quot;, &quot;aic.train.cook&quot;, &quot;tx_err.train.cook&quot;, 
                           &quot;tx_err.test.cook&quot;,&quot;deviance.train.stepaic&quot;, 
                           &quot;aic.train.stepaic&quot;, &quot;tx_err.train.stepaic&quot;,
                           &quot;tx_err.test.stepaic&quot;) 
 tab.reg.tot
 
 
#                          Min.  1st Qu.   Median     Mean  3rd Qu.      Max.
# DEV.TRAIN              1.052e+03 1136.000 1169.000 1404.000 1204.000 24940.000
# AIC.TRAIN              1.168e+03 1252.000 1285.000 1520.000 1320.000 25060.000
# tx_err.train           5.836e+00    6.554    6.798    6.811    7.010    11.280
 
# tx_err.test            6.128e+00    7.236    7.627    7.617    7.953     9.452
 
# deviance.train.cook    3.723e-06  345.900  370.600 3285.000 8092.000 18600.000
# aic.train.cook         1.160e+02  461.900  486.600 3401.000 8208.000 18710.000
# tx_err.train.cook      0.000e+00    2.336    2.615    3.158    3.854     8.836
 
# tx_err.test.cook       5.867e+00    6.910    7.432    7.703    8.018    12.580
 
# deviance.train.stepaic 1.076e+03 1149.000 1182.000 1179.000 1204.000  1255.000
# aic.train.stepaic      1.166e+03 1233.000 1274.000 1266.000 1292.000  1341.000
# tx_err.train.stepaic   6.065e+00    6.888    6.945    6.961    7.222     7.597
 
# tx_err.test.stepaic    6.714e+00    6.894    7.269    7.536    7.872     9.322</code></pre>
<div class="commentaire">
<p>Nous constatons qu’en moyenne les taux d’erreurs sont du même ordre.<br /></p>
<ul>
<li>
Modèle complet : <strong>tx_err.test : 7.617 %</strong>
<li>
Modèle hors seuils de Cook : <strong>tx_err.test.cook : 7.703 %</strong>
<li>
Modèle stepAic : <strong>tx_err.test.stepaic : 7.536 %</strong>
</ul>
<ol>
<li>
Le modèle complet s’exécute rapidement et obtient un bon résultat.
<li>
Retirer les individus hors seuils de Cook n’améliore pas en moyenne les résultats.
<li>
La procédure stepAic est très longue pour une améliration minime.
</ol>
Lors des itérations, en messages <em>warnings()</em>, j’ai pu constater des cas de non convergences. Toutefois, cela n’a pas provoqué d’erreur et j’ai bien eu 100 modèles générés.
</div>
<p>A travers cette expérience, nous avons pu voir qu’il n’y a pas de recette miracle pour améliorer le taux d’erreur du modèle. Dans l’absolu il nous faudrait un train le plus équilibré possible. <br /></p>
<p>A défaut d’utiliser la cross validation, avec la fonction <em>cv.glm {boot}</em>, qui ici renvoi une erreur (certainement un problème de convergence à l’issu de la création des échantillons). Nous allons chercher le “meilleur train” en se basant sur les taux d’erreurs obtenus sur l’échantillon test.</p>
<p><br /></p>
</div>
<div id="recherche-et-optimisation" class="section level3">
<h3>Recherche et optimisation</h3>
<p>Dans cette partie, nous allons tenter d’améliorer la qualité de prédiction en faisant diminuer le taux d’erreur global du modèle (les mals classés). <br /></p>
<p><b><u>La méthode :</u></b> <br /></p>
<ol>
<li>
Effectuer <span class="math inline">\(n\)</span> régression sur un train/test géneré de façon aléatoire.
<li>
Extraire le modèle (ici le modèle est complet) ayant obtenu le plus faible taux d’erreur.
<li>
Appliquer 100 nouveaux échantillons test au modèle selectionné.
</ol>
<p>Nous avons déja généré 100 echantillons train/test et effectué les régressions. il suffit de garder le meilleur train.<br /></p>
<pre class="r"><code>### bilan en fonction du taux d&#39;erreur de mal classés sur TEST

min.err.tst = min(tx_err.test)

best.iter.tst = which.min(tx_err.test)
best.seed.tst = seed+best.iter.tst

best.dev_tx.err=deviance.train[which.min(tx_err.test)] 
best.aic_tx.err=aic.train[which.min(tx_err.test)] 

bilan.test=data.frame(min.err.tst, best.iter.tst,  
                      best.seed.tst,  best.dev_tx.err, best.aic_tx.err, nb.iter, seed)                                


#résultat
bilan.test

# min.err.tst best.iter.tst best.seed.tst best.dev_tx.err best.ai_tx.errc nb.iter seed
# 6.127771    85            1508          1270.417        1386.417        100     1423</code></pre>
<div class="commentaire">
<p>Nous avons abtenus 6.13 % de mals classés à l’itération 85 pour le seed(1508). Nous allons garder ce modèle et le confronter à 100 nouveaux échantillons test.</p>
</div>
<pre class="r"><code>tx_err.test=c()

######
# Application des echantillons TEST sur le &quot;meilleur train&quot; 
# avec le seed 1508 
seed=1508 
#generation de l&#39;echantillon TRAIN
#rappel proportion au global &quot;email 61%&quot; &quot;spam 39%&quot;
set.seed(seed)

trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
DATASET.train &lt;- Don_spam[trainIndex, ]

#####
#REGRESSION SUR TOUTES LES VARIABLES
#####

##TRAIN
modele.best.train = glm(DATASET.train$spam ~ .,
                              family = binomial(link=&quot;logit&quot;), data=DATASET.train)

dev.best.train = modele.best.train$deviance
aic.best.train = modele.best.train$aic
#je retrouve bien la dev et aic du &quot;best train&quot;

for(i in 1:100){
 #initialisation du seed 
 set.seed(1423+i) #les memes individus test pour comparaison 
 
 #generation de l&#39;echantillon TEST
 trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
 DATASET.test &lt;- Don_spam[-trainIndex, ]
 
 res.prop.test.spam[i] =  round( (length(DATASET.test$spam[which(DATASET.test$spam==1)]) / 
                                   nrow(DATASET.test)) * 100,2)
 
 ## Application sur TEST
 pred.test = ifelse(predict(modele.best.train,DATASET.test,type=&quot;response&quot;) &gt;.5, 1,0)
 #cbind(predict(modele.boucle.tot.train,DATASET.test,type=&quot;response&quot;), pred.test) pour controle
 
 confusion.mat.boucle.tot.test = table(DATASET.test$spam, pred.test)
 
 tx_err.test[i] = (( confusion.mat.boucle.tot.test[1,2] + confusion.mat.boucle.tot.test[2,1] ) / 
                    dim(DATASET.test)[1] )*100 
 
 
}

summary(tx_err.test)


####
# essai 1 avec seed de départ à 1423 et un best train à 1508
####

## 7.2% d&#39;erreur en moyenne 
# Min.   1st Qu.  Median    Mean   3rd Qu.   Max. 
# 5.932  6.894    7.203     7.209  7.578     8.931

####
# essai 2 avec seed de départ à 4444 et un best train à 4532
####

## 6.45% d&#39;erreur en moyenne
# Min.   1st Qu.  Median    Mean    3rd Qu.    Max. 
# 4.889  6.128    6.454     6.438   6.780      7.823 </code></pre>
<div class="commentaire">
<p>Sur ces deux essais, j’ai pu obtenir en moyenne 7.2% et 6.45% d’erreur. Ce qui est une amélioration par rapport au comportement moyen du modèle complet (tx_err.test : 7.617% ). <br /></p>
<p>Cette méthode est proche de la validation croisée et donne des résultats encourageants.</p>
</div>
<p>Nous avons vu que selectionner un modèle par validation croisée semble efficace. Sur ce fichier en particulier, cela pose problème malheuresement avec la fonction <em>cv.glm {boot}</em>. <br /></p>
<p>Au sujet de validation croisée : <br /></p>
<p><a href="https://www.math.u-psud.fr/~poursat/STA212/hal_JES_validation-croisee.pdf">lien interessant</a> <br /></p>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
