<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">

<head>

<meta charset="utf-8" />
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>RPART : fichier ‘spam’</title>

<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/bootstrap.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<script src="site_libs/jqueryui-1.11.4/jquery-ui.min.js"></script>
<link href="site_libs/tocify-1.9.1/jquery.tocify.css" rel="stylesheet" />
<script src="site_libs/tocify-1.9.1/jquery.tocify.js"></script>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">code{white-space: pre;}</style>
<style type="text/css">
  pre:not([class]) {
    background-color: white;
  }
</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>



<style type="text/css">
h1 {
  font-size: 34px;
}
h1.title {
  font-size: 38px;
}
h2 {
  font-size: 30px;
}
h3 {
  font-size: 24px;
}
h4 {
  font-size: 18px;
}
h5 {
  font-size: 16px;
}
h6 {
  font-size: 12px;
}
.table th:not([align]) {
  text-align: left;
}
</style>

<link rel="stylesheet" href="include\style.css" type="text/css" />



<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
code {
  color: inherit;
  background-color: rgba(0, 0, 0, 0.04);
}
img {
  max-width:100%;
  height: auto;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
</style>


<style type="text/css">
/* padding for bootstrap navbar */
body {
  padding-top: 51px;
  padding-bottom: 40px;
}
/* offset scroll position for anchor links (for fixed navbar)  */
.section h1 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h2 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h3 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h4 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h5 {
  padding-top: 56px;
  margin-top: -56px;
}
.section h6 {
  padding-top: 56px;
  margin-top: -56px;
}
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #ffffff;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script>
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.parent().addClass('active');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  background: white;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->



<style type="text/css">

#TOC {
  margin: 25px 0px 20px 0px;
}
@media (max-width: 768px) {
#TOC {
  position: relative;
  width: 100%;
}
}


.toc-content {
  padding-left: 30px;
  padding-right: 40px;
}

div.main-container {
  max-width: 1200px;
}

div.tocify {
  width: 20%;
  max-width: 260px;
  max-height: 85%;
}

@media (min-width: 768px) and (max-width: 991px) {
  div.tocify {
    width: 25%;
  }
}

@media (max-width: 767px) {
  div.tocify {
    width: 100%;
    max-width: none;
  }
}

.tocify ul, .tocify li {
  line-height: 20px;
}

.tocify-subheader .tocify-item {
  font-size: 0.90em;
}

.tocify .list-group-item {
  border-radius: 0px;
}

.tocify-subheader {
  display: inline;
}
.tocify-subheader .tocify-item {
  font-size: 0.95em;
}

</style>



</head>

<body>


<div class="container-fluid main-container">


<!-- setup 3col/9col grid for toc_float and main content  -->
<div class="row-fluid">
<div class="col-xs-12 col-sm-4 col-md-3">
<div id="TOC" class="tocify">
</div>
</div>

<div class="toc-content col-xs-12 col-sm-8 col-md-9">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html">Analyses Statistiques</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Home</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Modèles
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li>
      <a href="reg_log_spam.html">Régression logistique</a>
    </li>
    <li>
      <a href="knn.html">KNN</a>
    </li>
    <li>
      <a href="rpart.html">RPART</a>
    </li>
  </ul>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div class="fluid-row" id="header">



<h1 class="title toc-ignore">RPART : fichier ‘spam’</h1>

</div>


<p><br /> <br /></p>
<div id="introduction" class="section level2">
<h2>Introduction</h2>
<p>Cet onglet à pour objectif de présenter la méthode CART (Classification And Regression Trees), Breiman <em>et al</em> (1984). La méthode CART sera présentée à travers la fonction <em>rpart {rpart}</em> implémentée dans <em>RStudio</em>.<br /> <br /> Le modèle <em>rpart {rpart}</em> sera utilisé sur les données “SPAM”. Pour rappel, le fichier de données “SPAM” se compose de 4601 lignes et 58 colonnes dont une variable classifiante binaire (‘0’:non spam/email ‘1’:spam). Une présentation des données et une rapide analyse descriptive sont disponibles sur l’onglet “Régression logistique”.<br /></p>
<ul>
<li>
<a href="https://berthetclement.github.io/website.github.io/reg_log_spam.html#les_donn%C3%A9es">Les données</a>
<li>
<a href="https://berthetclement.github.io/website.github.io/reg_log_spam.html#analyse_descriptive">Analyse descriptive</a>
</ul>
<p>La méthode CART s’inscrit dans la famille des méthodes de construction d’arbres de décision. En effet, CART est analogue à l’algorithme ID3 <a href="https://fr.wikipedia.org/wiki/Algorithme_ID3">ID3</a> ou encore les algorithmes C4.5 et C5.0 <a href="https://fr.wikipedia.org/wiki/Algorithme_C4.5">C4.5 C5.0</a>, à ceci près que CART construit un arbre binaire.<br /></p>
<p><br /></p>
</div>
<div id="methode-cart" class="section level2">
<h2>Méthode CART</h2>
<p>La méthode CART, Breiman <em>et al</em> (1984), est une méthode supervisée et non paramétrique de construction d’arbres de décision. Nous avons deux cas de figure : <br /></p>
<ul>
<li>
Arbre de régression (la variable à prédire est continue)
<li>
Arbre de classification (la variable à prédire est factorielle à k modalités)
</ul>
<p>Dans les deux cas, l’abre construit est binaire. <br /></p>
<p><b><u>Notations :</u></b></p>
<p>Soit un échantillon de données noté <span class="math inline">\(E=(X_n,j_n)_{1\le n \le N}\)</span> où <span class="math inline">\(X_n=(x_n^1,x_n^2,...,x_n^q)\)</span> est un réalisation de la variable aléatoire <span class="math inline">\(X=(X^1,X^2,...,X^q)\)</span> à valeurs dans <span class="math inline">\(\mathbb{R}^q\)</span>. Ici <span class="math inline">\(j_n\)</span> est la variable Y qui est soit qualitative (à <span class="math inline">\(j\)</span> modalités), soit quantitative.<br /> Soit <span class="math inline">\(t \subset E\)</span> un noeud de l’arbre, noté <span class="math inline">\(A\)</span>, construit sur l’échantillon de données d’apprentissage <span class="math inline">\(E\)</span>.<br /></p>
<p>Quelques notations supplémentaires sont nécessaires dans le cas d’une classification (Y qualitative) : <br /></p>
<ul>
<li>
On note la probabilité a priori de la classe <span class="math inline">\(j\)</span> : <span class="math inline">\(\pi_j= \frac{N_j}{N} \space (N_j=Card \{j_n;j_n=j\})\)</span>
<li>
<span class="math inline">\(t \subset E\)</span>, on note <span class="math inline">\(N(t)\)</span> le cardinal de l’ensemble <span class="math inline">\(t\)</span>
<li>
<span class="math inline">\(N_j(t)\)</span>, le cardinal de l’ensemble <span class="math inline">\(\{ (X_n,j_n) \in t;j_n=j \}\)</span>
<li>
Un estimateur <span class="math inline">\(P(j,t)\)</span> (probabilité qu’une observation appartienne à <span class="math inline">\(t\)</span> et qu’elle ait pour classe <span class="math inline">\(j\)</span>) est noté <span class="math inline">\(p(j,t)=\pi_j \frac{N_j(t)}{N_j}\)</span>
<li>
Un estimateur de <span class="math inline">\(P(t)\)</span> (probabilité d’appartenir au noeud <span class="math inline">\(t\)</span>) est noté <span class="math inline">\(p(t)=\sum_{j=1}^Jp(j,t)\)</span>
<li>
<p>Un estimateur <span class="math inline">\(P(j|t)\)</span> (probabilité a postériori qu’une observation ait la classe <span class="math inline">\(j\)</span> sachant qu’elle appartient à <span class="math inline">\(t\)</span>) est noté <span class="math inline">\(p(j|t)=\frac{p(j,t)}{p(t)}\)</span>, connaissant <span class="math inline">\(\pi_j\)</span> c’est égal à <span class="math inline">\(\frac{N_j(t)}{N(t)}\)</span></p>
</ul>
<p><br /></p>
<div id="construction-de-larbre" class="section level3">
<h3>Construction de l’arbre</h3>
<p>Que ce soit une classification ou une régression, CART construit un arbre binaire de façon itérative.<br /></p>
<p><strong>1-</strong> On cherche une règle de division binaire <span class="math inline">\(d=d(X^m,S)\)</span>.</p>
<ul>
<li>
Si <span class="math inline">\(X^m\)</span> est quantitative : <span class="math inline">\(X^m \le S \space (S \in \mathbb{R})\)</span>
<li>
Si <span class="math inline">\(X^m\)</span> est qualitative : <span class="math inline">\(X^m \in S\)</span> (<span class="math inline">\(S\)</span>, sous ensemble des modalités de <span class="math inline">\(X^m\)</span>)
</ul>
<p>Cette règle de division permet d’obtenir deux sous-ensembles <span class="math inline">\(t_g\)</span> et <span class="math inline">\(t_d\)</span>, issus de <span class="math inline">\(E\)</span> (la racine, noté aussi <span class="math inline">\(t_0\)</span>). L’objectif est de retenir la variable qui pour un seuil <span class="math inline">\(s\)</span>, rend la somme des hétérogénéités des noeuds fils minimale (pour Y qualitative). On dit aussi que la règle de décision optimale est celle qui minimise la somme des déviances intra classes des noeuds déscendants.</p>
<p>Pour <span class="math inline">\(Y\)</span> <strong><em>quantitative</em></strong>, on maximise <span class="math inline">\(\Delta \hat R (d,t)\)</span> :</p>
<ol style="list-style-type: none">
<li>
<span class="math inline">\(\Delta \hat R (d,t)=\hat R(t)-\hat R(t_g)-\hat R(t_d)\)</span><br /> Avec<br />
<li>
<span class="math inline">\(\hat R(t)=\frac{1}{Card(t)} \sum_{i;(X_i;j_i)\in t}(y_i- \bar y)^2\)</span> et <span class="math inline">\(\bar y =\frac{1}{Card(t)}\sum_{i;(X_i;j_i)\in t}y_i\)</span>
</ol>
<p>Pour <span class="math inline">\(Y\)</span> <strong><em>qualitative</em></strong>, on maximise <span class="math inline">\(\hat h(d,t)\)</span> (fonction d’hétérogénéité) :<br /></p>
<ol style="list-style-type: none">
<li>
<span class="math inline">\(\hat h(d,t)=\hat h(t)-p_g \hat h(t_g)-p_d \hat h(t_d)\)</span><br /> Avec <br /> <span class="math inline">\(p_g,p_d\)</span> : les <span class="math inline">\(\pi_j\)</span> respectifs
</ol>
<p>Deux fonctions d’hétérogénéité possibles : <br /></p>
<ol style="list-style-type: none">
<li>
<strong>L’entropie</strong> : <span class="math inline">\(\hat h(t)=-\sum_{j=1}^J p(j|t)log(p(j|t))\)</span>
<li>
<strong>L’indice de Gini</strong> : <span class="math inline">\(\hat h(t)=-\sum_{j \ne k}p(j|t)p(k|t)\)</span>
</ol>
<p><strong>2-</strong> Une fois le noeud contruit sur la variable, on continue de façon récurcive jusqu’à condition d’arrêt.<br /></p>
<p>Les conditions d’arrêt peuvent être :</p>
<ul>
<li>
Limiter la taille des sous-ensembles.
<li>
Utilisation d’un critère de pénalité.
</ul>
<p>A l’issu de cette première étape, l’algorithme CART construit un arbre dit “maximal” que l’on pourra rendre optimal par la suite à l’aide d’une procédure d’élagage. L’algorithme CART fournit également d’autres mesures par rapport aux divisions.</p>
<p><br /></p>
</div>
<div id="division-concurrente" class="section level3">
<h3>Division concurrente</h3>
<p>Nous avons vu précedemment que nous cherchons à maximiser <span class="math inline">\(\Delta \hat R (d,t)\)</span> ou <span class="math inline">\(\hat h(d,t)\)</span> selon la nature de <span class="math inline">\(Y\)</span>. Ce qui permet d’obtenir une divisions optimale. <br /></p>
<p>Notons <span class="math inline">\(d^*\)</span>, la division optimale pour un noeud <span class="math inline">\(t\)</span> qui maximise la décroissance de la déviance. Cette division optimale pour un noeud <span class="math inline">\(t\)</span> correspond au noeud <span class="math inline">\(t\)</span> de l’arbre construit (variable active).<br /></p>
<p>La division ou les divisions concurrentes sont les autres maximums et correspondent à d’autres variables pour un noeud <span class="math inline">\(t\)</span>.Ces variables ne feront pas parti de l’arbre construit.</p>
<p><br /></p>
</div>
<div id="division-de-substitution" class="section level3">
<h3>Division de substitution</h3>
<p>Le rôle de la division de substitution est d’obtenir une autre découpe proche de la découpe optimale (<em>primary split</em>) mais dans le sens de la règle d’acheminement. <em>CART</em> à travers les variables de substitutions, propose un traitement des valeurs manquantes <code>NA</code>. En effet, dans le cas d’une valeur manquante, il est peut optimal d’utiliser la meilleure variable concurrente qui ne respecte pas la règle d’acheminement de la variable en question (aiguillage vers le fils gauche ou droite du noeud). <em>CART</em> propose des découpes de substitution (<em>surrogate</em>) qui minimisent le nombre de désaccords avec la règle d’acheminement de la coupure optimale du noeud. <br /></p>
<p>Nous aurons par la suite l’occasion de voir le détail sur ces divisions de substitution.</p>
<p><br /></p>
</div>
<div id="importance-des-variables" class="section level3">
<h3>Importance des variables</h3>
<p>L’importance des variables est calculée dans les deux cas (régression ou classification).<br /></p>
<p>Importance d’une variable <span class="math inline">\(X^m\)</span> d’un arbre noté <span class="math inline">\(A\)</span> :</p>
<ol style="list-style-type: none">
<li>
<span class="math inline">\(I(X^m)=\sum_{t \in A} \Delta \hat R (d_m(t),t)\)</span> <strong>en régression</strong>
<li>
<span class="math inline">\(I(X^m)=\sum_{t \in A} \Delta \hat h (d_m(t),t)\)</span> <strong>en classification</strong>
</ol>
<p>La méthode CART est dite hiérarchique, car elle propose un classement des variables par importance (variables actives pour la consutruction de l’arbre mais aussi des variables de substitution). Cette hiérarchisation peut permettre par la suite d’élaborer un modèle plus robuste mais aussi servir à d’autres méthodes statistiques.</p>
<p><br /></p>
</div>
</div>
<div id="partie-modelisation-rstudio" class="section level2">
<h2>Partie modélisation RStudio</h2>
<p>Nous allons utiliser la méthode <strong><em>rpart {rpart}</em></strong>, cette méthode sera appliquée sur le jeu de données “SPAM”. Nous sommes ici dans un cas de classification binaire (Y=0 : “mail”, Y=1 : “spam”). <br /></p>
<p>Dans un premier temps, le modèle sera analysé à travers les données d’apprentissage (“train”) et par la suite nous pourrons y appliquer des données “test”.<br /><br /></p>
<div id="le-modele-rpart" class="section level3">
<h3>Le modèle RPART</h3>
<p>Afin de mieux comprendre la construction d’un arbre <strong><em>rpart</em></strong>, nous allons générer un arbre maximal “restreint”, avec les paramètres par défaut de la fonction <em>rpart</em>.<br /></p>
<p><b><u>Le modèle :</u></b></p>
<pre class="r"><code>####
####
####ECHANTILLON TRAIN/TEST
####
####

index &lt;- 1:nrow(Don_spam)
res.prop.train.spam=c()
res.prop.test.spam=c()
set.seed(1024)

#generation de l&#39;echantillon TRAIN
#rappel proportion au global &quot;email 61%&quot; &quot;spam 39%&quot;

trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
DATASET.train &lt;- Don_spam[trainIndex, ]

#proportion de spam % 
res.prop.train.spam =  round( (length(DATASET.train$spam[which(DATASET.train$spam==1)]) /nrow(DATASET.train)) * 100,2)

#generation de l&#39;echantillon TEST
DATASET.test &lt;- Don_spam[-trainIndex, ]
res.prop.test.spam =  round( (length(DATASET.test$spam[which(DATASET.test$spam==1)]) /nrow(DATASET.test)) * 100,2)

dim(DATASET.train) ; table(DATASET.train$spam)</code></pre>
<pre><code>## [1] 3067   58</code></pre>
<pre><code>## 
##    0    1 
## 1842 1225</code></pre>
<pre class="r"><code>library(rpart)
set.seed(1024)
arbre0 &lt;- rpart(DATASET.train$spam~.,data=DATASET.train) #lancement par défaut avec GINI
arbre0</code></pre>
<pre><code>## n= 3067 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
##  1) root 3067 1225 0 (0.60058689 0.39941311)  
##    2) cf_dollar&lt; 0.0445 2252  514 0 (0.77175844 0.22824156)  
##      4) wf_remove&lt; 0.06 2043  325 0 (0.84092022 0.15907978)  
##        8) cf_exclam&lt; 0.5085 1840  192 0 (0.89565217 0.10434783) *
##        9) cf_exclam&gt;=0.5085 203   70 1 (0.34482759 0.65517241)  
##         18) capital_run_length_total&lt; 35 72   16 0 (0.77777778 0.22222222) *
##         19) capital_run_length_total&gt;=35 131   14 1 (0.10687023 0.89312977) *
##      5) wf_remove&gt;=0.06 209   20 1 (0.09569378 0.90430622) *
##    3) cf_dollar&gt;=0.0445 815  104 1 (0.12760736 0.87239264)  
##      6) wf_hp&gt;=0.4 48    5 0 (0.89583333 0.10416667) *
##      7) wf_hp&lt; 0.4 767   61 1 (0.07953064 0.92046936) *</code></pre>
<pre class="r"><code>## représentation graphique de l&#39;arbre 
 plot(arbre0, main=&quot;Abre maximal restreint&quot;)
 text(arbre0,pretty=0,cex=0.8)</code></pre>
<p><img src="rpart_files/figure-html/unnamed-chunk-4-1.png" width="768" /></p>
<div class="commentaire">
<p>L’arbre maximal obtenu, avec les paramètres par défaut, comporte 5 noeuds et 6 feuilles (soit 5 variables). On peut voir que l’arbre prédit à gauche la classe ‘0’ (“mail”) et à droite la classe ‘1’ (“spam”). <br /></p>
<p>Pour analyser la sortie brute du modèle, nous avons :</p>
<ul>
<li>
<code>node</code> : le numéro du noeud <span class="math inline">\(t\)</span>.
<li>
<code>split</code> : le nom du noeud <span class="math inline">\(t\)</span>.
<li>
<code>n</code> : le nombre d’éléments du noeud <span class="math inline">\(t\)</span>.
<li>
<code>loss</code> : le nombre d’éléments de la classe minoritaire (traduit la perte) de <span class="math inline">\(t\)</span>.
<li>
<code>yval</code> : la classe majoritaire du noeud <span class="math inline">\(t\)</span>.
<li>
<code>(yprob)</code> : les proportions en fonction de la classe <span class="math inline">\(j\)</span> du noeud <span class="math inline">\(t\)</span>
</ul>
<p>Hormis pour la racine (root), la valeur du seuil de coupe de la variable est affiché avec le nom de la variable.</p>
</div>
<p>Maintenant que nous avons généré un arbre maximal avec les paramètres par défaut de la fonction. Il nous faut identifier ces paramètres et les analyser. <br /></p>
<p>Je précise que l’arbre généré avec les paremètres par défaut du modèle <em>rpart</em> est un arbre restreint et faussement maximal. Nous verrons par la suite qu’il est bien sûr possible de générer un arbre maximal. <br /></p>
</div>
<div id="rpart-detaille" class="section level3">
<h3>RPART détaillé</h3>
<p>La fonction <em>summary()</em> permet d’avoir le détail de construction de l’arbre. Cela serait trop long d’afficher tout le résultat de la procédure, un seul noeud et une feuille suffiront. <br /></p>
<p>En effet, un arbre est construit de façon récurcive selon les mêmes règles jusqu’à conditions d’arrêt.</p>
<pre class="r"><code>summary(arbre0)

# Call:
# rpart(formula = DATASET.train$spam ~ ., data = DATASET.train)
#   n= 3067 
# 
#           CP nsplit rel error    xerror       xstd
# 1 0.49551020      0 1.0000000 1.0000000 0.02214215
# 2 0.13795918      1 0.5044898 0.5216327 0.01836039
# 3 0.05142857      2 0.3665306 0.3918367 0.01642577
# 4 0.03265306      3 0.3151020 0.3232653 0.01515973
# 5 0.03102041      4 0.2824490 0.3151020 0.01499509
# 6 0.01000000      5 0.2514286 0.2775510 0.01419349
# 
# Variable importance
#                  cf_dollar                  wf_remove                     wf_000                   wf_money 
#                         29                         12                         11                         10 
# capital_run_length_longest                  cf_exclam                 wf_receive                   wf_order 
#                          8                          6                          6                          5 
#                      wf_hp   capital_run_length_total                     wf_hpl capital_run_length_average 
#                          3                          2                          1                          1 
#                    wf_your                     wf_650                  wf_telnet 
#                          1                          1                          1 
# 
# Node number 1: 3067 observations,    complexity param=0.4955102
#   predicted class=0  expected loss=0.3994131  P(node) =1
#     class counts:  1842  1225
#    probabilities: 0.601 0.399 
#   left son=2 (2252 obs) right son=3 (815 obs)
#   Primary splits:
#       cf_dollar &lt; 0.0445 to the left,  improve=496.6125, (0 missing)
#       cf_exclam &lt; 0.0785 to the left,  improve=484.0605, (0 missing)
#       wf_remove &lt; 0.01   to the left,  improve=395.6875, (0 missing)
#       wf_your   &lt; 0.405  to the left,  improve=389.2698, (0 missing)
#       wf_free   &lt; 0.075  to the left,  improve=371.6118, (0 missing)
#   Surrogate splits:
#       wf_000                     &lt; 0.045  to the left,  agree=0.831, adj=0.364, (0 split)
#       wf_money                   &lt; 0.03   to the left,  agree=0.828, adj=0.351, (0 split)
#       wf_receive                 &lt; 0.035  to the left,  agree=0.786, adj=0.194, (0 split)
#       capital_run_length_longest &lt; 72.5   to the left,  agree=0.785, adj=0.193, (0 split)
#       wf_order                   &lt; 0.095  to the left,  agree=0.784, adj=0.188, (0 split)
# 
# Node number 5: 209 observations
#   predicted class=1  expected loss=0.09569378  P(node) =0.06814477
#     class counts:    20   189
#    probabilities: 0.096 0.904       </code></pre>
<p>La fonction <em>summary()</em> fournit plusieurs types d’information : <br /></p>
<ul>
<li>
Un objet <code>arbre0$cptable</code> : matrice d’information du choix du cp optimal pour l’élagage (pruning).
<li>
Un objet <code>arbre0$variable.importance</code> : l’importance de chaque variable (hiérarchisation).
<li>
Un objet <code>arbre0$splits</code> : matrice d’information sur les noeuds <span class="math inline">\(t\)</span>.
</ul>
<p>Nous allons dans un premier temps nous focaliser sur les “splits”, a travers ces splits nous allons étudier plusieurs aspects.</p>
<ul>
<li>
La variable qui maximise la fonction d’hétérogénéité pour chaque noeud <span class="math inline">\(t\)</span> est une variable active.
<li>
Les variables concurrentes : les autres maximum de la fonction d’hétérogénéité.<br />

<li>
Les variables de substitutions (surrogate).
</ul>
<p><br /></p>
<div id="fonction-dheterogeneite" class="section level4">
<h4>Fonction d’hétérogénéité</h4>
<p>Avant d’aller plus loin, il est important de spécifier que l’on peut choisir la fonction d’hétérogénéité. <br /></p>
<ul>
Les options du modèle :
<li>
<code>parms = list(split = "gini")</code> pour l’indice de Gini.
<li>
<code>parms = list(split = "information")</code> pour l’Entropie.<br />

</ul>
<p>On peut le vérifier avec l’objet en sortie du modèle <code>arbre0$parms$split</code> (1:Gini, 2:Entropie). <br /></p>
<p>Pour les deux fonctions, cela ne change rien à l’affichage, les seuils de coupe peuvent être différents ou l’ordre des variables. <br /></p>
<p>⚠⚠⚠<br /> Nous allons utiliser la valeur par défaut de <em>rpart</em> et travailler avec l’indice de Gini.</p>
<p><br /></p>
</div>
<div id="autres-options" class="section level4">
<h4>Autres options</h4>
<p>Quelques options supplémentaires à l’aide de <code>rpart.control()</code>. Nous allons aussi voir quelles sont les valeurs par défaut.<br /></p>
<p>Ajouter des contraintes sur les noeuds et feuilles :</p>
<ul>
Les options du modèle par défaut :
<li>
<code>minsplit = 20</code> : nombre d’observations minimum par noeud <span class="math inline">\(t\)</span>.
<li>
<code>minbucket = round(minsplit/3)</code> nombre d’observations minimum par feuille.<br />

</ul>
<p>Fixer le paramètre de compléxité, par défaut <code>cp = 0.01</code>. Nous détaillerons plus tard ce que signifie ce critère de pénalité. Pour faire simple, plus le cp est proche de 1, moins l’arbre sera profond. <br /></p>
<p>Modifier l’affichage des splits en sortie :</p>
<ul>
Les options du modèle par défaut :
<li>
<code>maxcompete = 4</code> : nombre de splits concurrents.
<li>
<code>maxsurrogate = 5</code> nombre de variables de substitution affichées.<br />

</ul>
<p>Les variables “surrogate” ont un impact sur la liste finale des variables d’importance ainsi que sur le temps de calcul de la méthode <em>rpart</em>. D’autres options sont disponibles via <code>rpart.control()</code>. <br /></p>
<p><br /></p>
</div>
<div id="analyse-des-splits" class="section level4">
<h4>Analyse des splits</h4>
<p>Pour cette partie nous avons besoin essentiellement de la matrice d’information <code>arbre0$splits</code>. Cette matrice, avec les options par défaut du modèle <em>rpart</em> nous livre pour chaque noeud <span class="math inline">\(t\)</span> :</p>
<ul>
<li>
En tête de liste : la variable qui réalise le gain maximum (variable active de l’arbre).
<li>
4 autres variables concurrentes.<br /> Suivi des lignes <br />
<li>
En tête de liste de la partie surrogate : la variable ayant la concordance la plus forte avec la variable active du noeud.
<li>
4 autres variables surrogate (par ordre de concordance avec la variable active).
</ul>
<p>Ainsi desuite jusqu’a la fin de l’arbre. <br /></p>
<p>Regardons pour 2 neouds <span class="math inline">\(t\)</span> : <br /></p>
<pre class="r"><code>arbre0$splits[1:20,]</code></pre>
<pre><code>##                            count ncat     improve    index         adj
## cf_dollar                   3067   -1 496.6125453   0.0445 0.000000000
## cf_exclam                   3067   -1 484.0604765   0.0785 0.000000000
## wf_remove                   3067   -1 395.6875398   0.0100 0.000000000
## wf_your                     3067   -1 389.2697760   0.4050 0.000000000
## wf_free                     3067   -1 371.6117590   0.0750 0.000000000
## wf_000                         0   -1   0.8311053   0.0450 0.364417178
## wf_money                       0   -1   0.8275187   0.0300 0.350920245
## wf_receive                     0   -1   0.7857842   0.0350 0.193865031
## capital_run_length_longest     0   -1   0.7854581  72.5000 0.192638037
## wf_order                       0   -1   0.7841539   0.0950 0.187730061
## wf_remove                   2252   -1 210.5972844   0.0600 0.000000000
## cf_exclam                   2252   -1 180.4957464   0.0795 0.000000000
## wf_free                     2252   -1 171.7706446   0.1350 0.000000000
## wf_your                     2252   -1 107.9866362   0.5950 0.000000000
## capital_run_length_average  2252   -1 106.1893594   3.6835 0.000000000
## capital_run_length_longest     0   -1   0.9111901 131.5000 0.043062201
## wf_receive                     0   -1   0.9098579   0.3700 0.028708134
## wf_business                    0   -1   0.9089698   4.1900 0.019138756
## cf_hash                        0   -1   0.9085258   1.5650 0.014354067
## wf_3d                          0   -1   0.9076377   7.1250 0.004784689</code></pre>
<p>Nous avons : <br /></p>
<ul>
<li>
<code>count</code> : le nombre d’osbservations pour chaque noeud <span class="math inline">\(t\)</span>.
<li>
<code>ncat</code> : “+/-1” pour des variables continues.
<li>
<code>improve</code> : importance de la variable pour le noeud <span class="math inline">\(t\)</span> (pour les surrogate c’est la valeur <code>agree</code> du <code>summary()</code>).
<li>
<code>index</code> : la valeur du seuil de coupe de la variable.
<li>
<code>adj</code> : la concodance pénalisée (“adjusted concordance”).
</ul>
<p>Pour mieux comprendre la sortie et la nature des valeurs, je vais détailler les colonnes <code>improve</code>, <code>index</code>, <code>agree</code> et <code>adj</code>.<br /></p>
<p>Comment calculer ces valeurs ? <br /></p>
<ul>
<li>
<code>improve</code> : le maximum de <span class="math inline">\(\hat h(d,t)=\hat h(t)-p_g \hat h(t_g)-p_d \hat h(t_d)\)</span> multiplié par le nombre d’observations du noeud <span class="math inline">\(t\)</span>.
<li>
<code>index</code> : est le seuil optimal <span class="math inline">\(d\)</span> de <span class="math inline">\(\hat h(d,t)\)</span> noté <span class="math inline">\(d^*\)</span>.
<li>
<code>agree</code> : taux de concordance entre deux variables (calculé à partir d’une table de concordance).
<li>
<code>adj</code> : taux de concordance ajusté (ou pénalisé), proportionnel au taux <code>agree</code>.
</ul>
<p>Nous allons tenter de retrouver, à travers la fonction suivante, l’affichage <code>arbre0$splits[1:20,]</code>. L’objectif est de comprendre et de retrouver les valeurs des splits pour les variables concurrentes et de substitution. <br /></p>
<p><b><u>La fonction :</u></b></p>
<pre class="r"><code>########
# fonction fournissant les valeurs improve, index, agree, adj (importance, seuils de coupure,
#  taux de concordance et taux de concordance ajusté) pour un noeud t
# 
# En parametres : 
#  1: objet contenant les (X,Y) 
#  2: le nom de l&#39;objet 
#  3: le nom de la var classifiante
########

splits=function(X, nom.df, nom.y){
 
 list.variable=c();mat=c()
 
 # selection de la variable classifiante
 var.y = paste0(nom.df,&quot;$&quot;,nom.y)
 Y.var = eval(parse(text = var.y)) 
 
 for(j in 1:(length(names(X))-1) ){
  
  var=names(X)[j]  #i 
  var=paste0(nom.df,&quot;$&quot;,var)
  
  X.var = eval(parse(text = var)) # selection de la colonne
  
  # init
  gini=c()
  
  l=1000
  cx=seq(min(X.var),max(X.var)/5,length.out=l)
  
  p=table(Y.var)[2]/sum(table(Y.var)) ; p=as.vector(p)
  # root
  gini.0 = (2*p*(1-p)) ; gini.0
  
  #calcul des n seuils
  for (i in 1:l) { #calcul des seuils
   
   p.g=table(Y.var[X.var&lt;cx[i]]  )[2]/length(X.var[X.var&lt;cx[i]]) ; p.g=as.vector(p.g)
   p.d=table(Y.var[X.var&gt;=cx[i]]  )[2]/length(X.var[X.var&gt;=cx[i]]) ; p.d=as.vector(p.d)
   
   #gini
   gauche.gini = (2*p.g*(1-p.g))
   droite.gini = (2*p.d*(1-p.d))
   
   gini[i] = gini.0 - (length(X.var[X.var&lt;cx[i]]) / length(Y.var) * gauche.gini) - 
    (length(X.var[X.var&gt;=cx[i]]) /length(Y.var) * droite.gini)
   
  }#fin boucle seuils
  
  # cr?ation matrice de r?sultat 
  # le max du gain et le seuil associ? 
  
  list.variable[j] = names(X)[j] # noms des colonnes
  
  # les valeurs
  max.gini = round(max(gini, na.rm = T), 4)
  seuil.gini = round(cx[which.max(gini)], 4)
  improve = max.gini * length(Y.var)
  
  mat = rbind(mat, c(improve, max.gini, seuil.gini) )
  
 }
 
 row.names(mat) &lt;- list.variable
 
 #####
 # Primary split
 # on veut en sortie 5 variables dont 4 cocurrentes 
 #####
 
 ind = order(mat[,1], decreasing = T)[1:5]
 mat = mat[ind,]
 
 mat = data.frame(improve=mat[,1], agree=0, adj=0, gini=mat[,2], seuil.gini=mat[,3], seuil.agree=0)

 #####
 # Partie surrogate
 #####
 mat.surro = c();agree=c();adj=c()

 # concordance avec la première variable (max improve &lt;=&gt; gini)
 
 # la variable primary split
  primary.split = row.names(mat[1,]) # le nom
 
  p.split=paste0(nom.df,&quot;$&quot;,primary.split)
  p.split=eval(parse(text = p.split)) # la variable
 
  l=5000 # pour seuils
 
 # liste des variables sans le primary split 
  list.surro = list.variable[list.variable != primary.split]
 
 # le seuil du primary split
  s.p.split = mat[1, &quot;seuil.gini&quot;] # arbre0$splits[1, &quot;index&quot;] autre moyen
 
 # le cut pour ki2
  primary.cut = cut(p.split, c(-0.1, s.p.split, max(p.split)) )

 for(j in 1:length(list.surro)){
  
  # selection de la colonne
   var=list.surro[j]  #j sans la colonne primary split
   var=paste0(nom.df,&quot;$&quot;,var)
   X.var = eval(parse(text = var))
  
  # les seuils pour la variable 
  cx=seq(min(X.var),max(X.var),length.out=l)
  
  #calcul des n seuils
  for (i in 1:l) { #calcul des seuils
   
   # le cut pour la variable en fonction du seuil
    X.var.cut = cut(X.var, c(-0.1, cx[i], max(X.var)+0.1))
    
   # table de concordance
    t.c=table(primary.cut, X.var.cut)
   
   # taux de concordance  
    agree[i] = sum(diag(t.c)) / sum(t.c)
   
   # taux de concordance ajusté
    l1=sum(t.c[1,])
    l2=sum(t.c[2,])
    max.ligne = max(l1,l2)
    adj[i] = (sum(diag(t.c)) - max.ligne) / (sum(t.c)-max.ligne)
   
  }
  
  # pour affichage en sortie
   maxagree = round(max(agree), 4)
   maxadj = round(max(adj), 4)
   seuil.agree = round(cx[which.max(agree)], 4)
   seuil.adj = round(cx[which.max(adj)], 4)
  
  mat.surro = rbind(mat.surro, c(maxagree, maxadj, seuil.agree, seuil.adj) )
  
 }# fin surrogate
  
  # noms des variables 
  row.names(mat.surro) &lt;- list.surro
  
  # tri par odre décroissant agree et nb ligne à afficher 
   
  ind.surro = order(mat.surro[,1], decreasing = T)[1:5]
  
  mat.surro.order = mat.surro[ind.surro,]

  # pour les surrogate : improve=0, gini=0, seuil.gini=0 
  mat.surro = data.frame(improve=0, agree=mat.surro.order[,1], adj=mat.surro.order[,2], 
                         gini=0, seuil.gini=0, 
                         seuil.agree=mat.surro.order[,3])
  
  # concatenation avec les surrogate 
  mat=rbind(mat, colnames(mat.surro), mat.surro)
  row.names(mat)[6] = &quot;SURROGATE&quot;
  
  return(mat)
}</code></pre>
<p><b><u>Pour le premier noeud :</u></b></p>
<pre class="r"><code>split.t1 = splits(DATASET.train, &quot;DATASET.train&quot;, &quot;spam&quot;)
split.t1

#                             improve  agree    adj   gini seuil.gini seuil.agree
# cf_dollar                  496.5473      0      0 0.1619     0.0445           0
# cf_exclam                  483.9726      0      0 0.1578      0.078           0
# wf_remove                   395.643      0      0  0.129     0.0015           0
# wf_your                    389.2023      0      0 0.1269     0.4004           0
# wf_free                    371.7204      0      0 0.1212     0.0721           0
# SURROGATE                   improve  agree    adj   gini seuil.gini seuil.agree
# wf_000                            0 0.8311 0.3644      0          0      0.0406
# wf_money                          0 0.8275 0.3509      0          0        0.02
# wf_receive                        0 0.7858 0.1939      0          0      0.0301
# capital_run_length_longest        0 0.7855 0.1926      0          0      72.928
# wf_order                          0 0.7842 0.1877      0          0      0.0906</code></pre>
<div class="commentaire">
<p><strong><em>On execute la fonction avec les mêmes données que pour le modèle rpart</em></strong>. Je retrouve bien pour le premier noeud, les informations de mon modèle <code>arbre0$splits</code>. <br /></p>
<ul>
<li>
Le “primary split” <code>cf_dollar</code> avec le même seuil de coupure (<code>index</code>) et la valeur <code>improve</code> maximale.
<li>
L’odre des 4 variables concurrentes par improve décroissant est ok ainsi que les valeurs.
<li>
Les variables “surrogate” dans l’odre décroissant ainsi que les valeurs sont ok.
</ul>
</div>
<p><b><u>Pour le second noeud :</u></b></p>
<pre class="r"><code># deuxieme split
 new.dataset = DATASET.train[DATASET.train$cf_dollar&lt;0.0445, ] 
 dim(new.dataset) # 2252   58 ok avec l&#39;arbre
 table(new.dataset$spam)
 # 0    1 
 # 1738  514 ok avec le noeud 2

 split.t2 = splits(new.dataset, &quot;new.dataset&quot;, &quot;spam&quot;)
 split.t2

 #                             improve  agree    adj   gini seuil.gini seuil.agree
 # wf_remove                   210.562      0      0 0.0935     0.0408           0
 # cf_exclam                  179.4844      0      0 0.0797      0.078           0
 # wf_free                    171.8276      0      0 0.0763     0.1321           0
 # wf_your                     108.096      0      0  0.048     0.5916           0
 # capital_run_length_average 104.2676      0      0 0.0463     3.6595           0
 # SURROGATE                   improve  agree    adj   gini seuil.gini seuil.agree
 # capital_run_length_longest        0 0.9112 0.0431      0          0    131.2725
 # wf_receive                        0 0.9099 0.0287      0          0      0.3602
 # wf_business                       0  0.909 0.0191      0          0      3.5704
 # cf_hash                           0 0.9085 0.0144      0          0      1.5628
 # wf_3d                             0 0.9076 0.0048      0          0      7.0726</code></pre>
<div class="commentaire">
<p>On exécute la fonction avec les données segmentées sur le seuil de la variable “primary split” (<code>cf_dollar&lt;0.0445</code>).<br /></p>
<p>c’est ok avec la sortie rpart <code>arbre0$splits</code>.</p>
</div>
<p>⚠⚠⚠<br /></p>
<p>La fonction est assez lente, l’objectif étant de vérifier les calculs. De plus la difficulté est de trouver les seuils pour les tables de concordance ainsi que de fabriquer les intervalles en fonction des seuils. Cette partie pourrait être optimisée car ici gourmande en temps de calcul. <br /></p>
<p>⚠⚠⚠<br /></p>
<p>Maintenant que nous avons compris, l’affichage et le détail de calcul des splits nous pouvons passer aux données de la matrice d’information <code>arbre0$cptable</code>.<br /></p>
<p><br /></p>
</div>
<div id="analyse-de-la-table-cp" class="section level4">
<h4>Analyse de la table CP</h4>
<p>Nous allons passer à l’analyse du <em>cp</em> ou paramètre de complexité ou encore critère de pénalité. <br /></p>
<p>Nous avons vu que <em>rpart</em> fournit un <em>arbre non maximal</em>, en effet il est pénalisé (ou restreint) par le paramètre <em>cp</em> que l’on trouve dans les options <code>rpart.control()</code> du modèle. Pour rappel, par défaut les options sont : <br /></p>
<p> <code>rpart.control(minsplit = 20, minbucket = round(minsplit/3),cp = 0.01,...)</code> avec <strong><em>cp = 0.01</em></strong>. <br /></p>
<p>Regardons la table cp fournit par le modèle : <br /></p>
<pre class="r"><code>arbre0$cptable</code></pre>
<pre><code>##           CP nsplit rel error    xerror       xstd
## 1 0.49551020      0 1.0000000 1.0000000 0.02214215
## 2 0.13795918      1 0.5044898 0.5346939 0.01852748
## 3 0.05142857      2 0.3665306 0.4081633 0.01669956
## 4 0.03265306      3 0.3151020 0.3232653 0.01515973
## 5 0.03102041      4 0.2824490 0.3118367 0.01492832
## 6 0.01000000      5 0.2514286 0.2800000 0.01424812</code></pre>
<p>La table cp est une matrice d’information afin de choisir le <em>cp</em> optimal pour l’élagage (pruning). En effet l’objectif est de retenir le critère <em>cp</em> qui minimise l’erreur de prédiction. Pour que ce choix du critère <em>cp</em> soit robuste, le modèle <em>rpart</em> founit également un taux d’erreur <code>xerror</code> obtenu par validation croisée (erreur moyenne) et son écart type <code>xstd</code>. <br /></p>
<p>A chaque étape (à chaque ligne de la table cp), <em>rpart</em> génère un arbre de plus en plus complexe jusqu’à atteindre une limite fixée par <em>cp</em>. <br /></p>
<p><b><u>Les étapes de construction de l’arbre :</u></b></p>
<pre class="r"><code>anim &lt;-function(data, data.y, cp)
{
 var = paste0(data,&quot;$&quot;,data.y,&quot;~.&quot;)
 u=c()
 z &lt;- rpart(var,data=eval(parse(text = data)),
            control = rpart.control(cp=cp))
 cp.list=z$cptable[,1]
 
 for(i in 1:(length(z$cptable[,1])-1)) #la valeur cp max est l&#39;arret 
 {
  
  u &lt;- rpart(var,data=eval(parse(text = data)),
             control = rpart.control(cp=as.vector(cp.list[i])-0.0001))
  
  plot(u, main=paste0(&quot;Arbre &quot;,&quot;cp = &quot;, round(cp.list[i], 4)), asp=i)
  text(u,pretty=0,cex=0.9)
  Sys.sleep(1)
 }
 #return(cp.list)
}
anim(&quot;DATASET.train&quot;, &quot;spam&quot;, 0.01)</code></pre>
<p><img src="rpart_files/figure-html/unnamed-chunk-11-1.png" width="576" /><img src="rpart_files/figure-html/unnamed-chunk-11-2.png" width="576" /><img src="rpart_files/figure-html/unnamed-chunk-11-3.png" width="576" /><img src="rpart_files/figure-html/unnamed-chunk-11-4.png" width="576" /><img src="rpart_files/figure-html/unnamed-chunk-11-5.png" width="576" /></p>
<div class="commentaire">
On remarque que l’arbre se complexifie à mesure que le <em>cp</em> décroît pour s’arrêter à la valeur fixée en paramètre. On se doute que l’arbre avec les paramètres par défaut n’est pas forcèment optimal ou même suffisant à faire un choix.
</div>
<p>Avant de continuer, il nous faut comprendre comment sont obtenues les valeurs de la table cp. <br /></p>
<p><b><u>Calcul du cp :</u></b></p>
<p>Le <em>cp</em> est obtenu pour chaque noeud <span class="math inline">\(t\)</span>. C’est à partir de la valeur de perte du noeud root <code>loss</code> que le calcul est fait. Prenons les 3 premières lignes (nsplit = 0, 1 , 2). <br /></p>
<pre class="r"><code># calcul du cp 

# arbre0
# n= 3067 
# node), split, n, loss, yval, (yprob),
#  * denotes terminal node

# 1) root 3067 1225 0 (0.60058689 0.39941311)  
#  2) cf_dollar&lt; 0.0445 2252  514 0 (0.77175844 0.22824156) 
#  3) cf_dollar&gt;=0.0445 815  104 1 (0.12760736 0.87239264)  

# cp du noeud 0 
(1225-514-104)/1225</code></pre>
<pre><code>## [1] 0.4955102</code></pre>
<pre class="r"><code># 0.4955102 le cp du t1 ok 

# noeud 1
# 2) cf_dollar&lt; 0.0445 2252  514 0 (0.77175844 0.22824156) 
# 4) wf_remove&lt; 0.06 2043  325 0 (0.84092022 0.15907978) 
# 5) wf_remove&gt;=0.06 209   20 1 (0.09569378 0.90430622) *
(514-325-20)/1225 # 0.1379592 ok avec cp </code></pre>
<pre><code>## [1] 0.1379592</code></pre>
<pre class="r"><code>#noeud 2
# 4) wf_remove&lt; 0.06 2043  325 0 (0.84092022 0.15907978) 
# 8) cf_exclam&lt; 0.5085 1840  192 0 (0.89565217 0.10434783) *
# 9) cf_exclam&gt;=0.5085 203   70 1 (0.34482759 0.65517241)  
(325-192-70)/1225 # 0.05142857 ok cp nsplit 2 etc etc </code></pre>
<pre><code>## [1] 0.05142857</code></pre>
<pre class="r"><code>arbre0$cptable[1:3,1]</code></pre>
<pre><code>##          1          2          3 
## 0.49551020 0.13795918 0.05142857</code></pre>
<div class="commentaire">
<p>Pour chaque noeut <span class="math inline">\(t\)</span></p>
<ol>
<li>
Prendre la valeur <code>loss</code> du noeud root.
<li>
Prendre la valeur <code>loss</code> du noeud <span class="math inline">\(t\)</span>.
<li>
Prendre les valeurs <code>loss</code> des fils <span class="math inline">\(t_g\)</span> et <span class="math inline">\(t_d\)</span>.
</ol>
<p>On soustrait les <code>loss</code> de <span class="math inline">\(t-t_g-t_d\)</span> et on divise par le <code>loss</code> du root.</p>
</div>
<p><b><u>Calcul de <code>rel error</code> :</u></b></p>
<p>La valeur <code>rel error</code> est présente dans la matrice d’information <code>arbre0$cptable</code>. <br /></p>
<pre><code>##           CP nsplit rel error    xerror       xstd
## 1 0.49551020      0 1.0000000 1.0000000 0.02214215
## 2 0.13795918      1 0.5044898 0.5346939 0.01852748
## 3 0.05142857      2 0.3665306 0.4081633 0.01669956
## 4 0.03265306      3 0.3151020 0.3232653 0.01515973
## 5 0.03102041      4 0.2824490 0.3118367 0.01492832
## 6 0.01000000      5 0.2514286 0.2800000 0.01424812</code></pre>
<p>Cette valeur <code>rel error</code> est l’erreur de l’arbre pour chaque valeur de <em>cp</em>. C’est à dire le taux d’erreur des mal classés de l’arbre sur les données du train <code>DATASET.train</code> divisé par la valeur loss du noeud root. <br /></p>
<p>  <code>rel error</code> = taux erreur (matrice de confusion obtenue à partir des <code>predict()</code>) / <code>expected loss</code> du noeud root. <br /></p>
<p>Il y a un “décalagage” dans la table car à ligne 6, quand la valeur du cp est atteinte, l’algorithme s’arrête. <code>rel error</code> vaut 1 au niveau root (expected loss=0.3994131 / expected loss=0.3994131 = 1). <br /></p>
<p>Les étapes de calcul : <br /></p>
<ol>
<li>
Construire un arbre pénalisé par le <em>cp</em> de chaque ligne de la table.
<li>
Effectuer les prédictions sur les donneés train et obtenir une matrice de confusion.
<li>
Calculer le taux d’erreur (erreur de resubstitution) à partir de la matrice de confusion.
<li>
Déduire <code>rel error</code> en divisant le taux d’erreur par la valeur loss de la racine de l’arbre.
</ol>
<p>Vérification : <br /></p>
<pre class="r"><code># Calcul rel error 
# pour nsplit = 0 
# on a besoin du taux d&#39;erreur de l&#39;arbre nsplit = 0 

rel.error0 &lt;- rpart(DATASET.train$spam~.,data=DATASET.train,
                    control = rpart.control(minsplit = 20, cp = 0.495510))
 

#prédiction sur l&#39;échantillon train.
pred0 &lt;- predict(rel.error0,newdata=DATASET.train,type=&quot;class&quot;)

#matrice de confusion
mc &lt;- addmargins(table(DATASET.train$spam,pred0))

#taux d&#39;erreur
erreur0 &lt;- (mc[2,1]+mc[1,2])/mc[3,3] # pourcentage total de m.c 


error0= (mc[2,1]+mc[1,2])/(mc[2,1]+mc[2,2]) # pourcentage de m.c par rapport aux m.c du root


# pour nsplit 1
rel.error1 &lt;- rpart(DATASET.train$spam~.,data=DATASET.train,
                    control = rpart.control(minsplit = 20, cp = 0.137959))

#prédiction sur l&#39;échantillon train.
pred1 &lt;- predict(rel.error1,newdata=DATASET.train,type=&quot;class&quot;)
#print(summary(pred0))
#matrice de confusion
mc &lt;- addmargins(table(DATASET.train$spam,pred1))

#taux d&#39;erreur
erreur1 &lt;- (mc[2,1]+mc[1,2])/mc[3,3] # pourcentage total de m.c 

error1= (mc[2,1]+mc[1,2])/(mc[2,1]+mc[2,2]) # pourcentage de m.c par rapport aux m.c du root

rel.error0 #arbre avec un noeud</code></pre>
<pre><code>## n= 3067 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
## 1) root 3067 1225 0 (0.6005869 0.3994131)  
##   2) cf_dollar&lt; 0.0445 2252  514 0 (0.7717584 0.2282416) *
##   3) cf_dollar&gt;=0.0445 815  104 1 (0.1276074 0.8723926) *</code></pre>
<pre class="r"><code>print(erreur0) # erreur &quot;en resubstitution&quot;</code></pre>
<pre><code>## [1] 0.2014998</code></pre>
<pre class="r"><code>print(error0) # rel error</code></pre>
<pre><code>## [1] 0.5044898</code></pre>
<pre class="r"><code>rel.error1 #arbre avec 2 noeuds</code></pre>
<pre><code>## n= 3067 
## 
## node), split, n, loss, yval, (yprob)
##       * denotes terminal node
## 
## 1) root 3067 1225 0 (0.60058689 0.39941311)  
##   2) cf_dollar&lt; 0.0445 2252  514 0 (0.77175844 0.22824156)  
##     4) wf_remove&lt; 0.06 2043  325 0 (0.84092022 0.15907978) *
##     5) wf_remove&gt;=0.06 209   20 1 (0.09569378 0.90430622) *
##   3) cf_dollar&gt;=0.0445 815  104 1 (0.12760736 0.87239264) *</code></pre>
<pre class="r"><code>print(erreur1) # erreur &quot;en resubstitution&quot;</code></pre>
<pre><code>## [1] 0.1463971</code></pre>
<pre class="r"><code>print(error1) # rel error</code></pre>
<pre><code>## [1] 0.3665306</code></pre>
<div class="commentaire">
<p>Pour la première ligne, nspit = 0, on obtient bien un arbre avec un seul noeud (arbre pénalisé par le cp). les taux d’erreur : <br /></p>
<ul>
nsplit=0
<li>
Taux d’erreur de prédiction du modèle : 0.2014998.
<li>
Déduction du <code>rel error</code> : 0.5044898. <br /> nsplit=1
<li>
Taux d’erreur de prédiction du modèle : 0.1463971.
<li>
Déduction du <code>rel error</code> : 0.3665306.
</ul>
<p>On retrouve bien les valeurs de <code>rel error</code> en fonction de la valeur du <em>cp</em>.</p>
</div>
<p>Pour ce qui est des valeurs <code>xerror</code> et <code>xstd</code>, nous pouvons les optenirs par validation croisée tout comme le fait le modèle <em>rpart</em>.<br /></p>
<p><b><u>Validation croisée :</u></b></p>
<p>On retourve dans les options de <em>rpart</em>, un paramètre permettant de fixer le nombre de sous échantillons de la validation croisée. <br /></p>
<p> <code>rpart.control(xval = 10, ...)</code>, ici nous avons 10 sous échantillons. <br /></p>
<p>Nous ne connaissons pas les “index” (numéros des individus) des sous échantillons de notre échantillon de départ <code>DATASET.train</code> qui sont utilisés dans la cross validation de <em>rpart</em> mais nous devrions trouver les mêmes ordres de grandeur pour <code>xerror</code> et <code>xstd</code>. <br /></p>
<p>L’objectif de cette partie est de calculer par cross validation, l’erreur de prédiction et son écart type associé. <br /> On se basera sur la profondeur de <code>arbre0</code> qui est de 4, nous avons en effet 4 niveaux soit 16 noeuds possibles. <br /></p>
<p>Les étapes :</p>
<ol>
<li>
Construire un arbre pour une profondeur donnée (ici de 1 à 4).
<li>
Calculer par cross validation la valeur <code>rel error</code> de l’arbre de profondeur $j $.
<li>
Calculer la moyenne des ces <span class="math inline">\(j\)</span> <code>rel error</code> et l’écart type.
</ol>
<pre class="r"><code>##### 
# calcul de xerror xstd 
# validation croisée 
#####

 #init 
 n=dim(DATASET.train)[1]
 K=10 # nombres de blocs de la c.v
 size=n%/%K  # taille des blocs en nombre entier
 Ind=rep(1:K,size)
 set.seed(1024)
 block=sample(Ind,length(Ind),rep=F)
 block=as.factor(block) # permet de nommer facilement les blocs
 
 # profondeux max de l&#39;arbre 
 max.profondeur = 4 # défini sur arbre0
 
 res=c()
 for(j in 1:max.profondeur ) 
 {
  
  # Début de la c.v
  err=c();cp.x=matrix(nrow = 10,byrow = T) # vecteur des erreurs
  
  for(i in 1:K) { 
   # pour calcul de l&#39;erreur normalisée
   loss = table(DATASET.train[block!=i,]$spam)[&quot;1&quot;]/length(DATASET.train[block!=i,]$spam)
    
   # arbre de profondeur j 
   treecp= rpart(DATASET.train[block!=i,]$spam~ ., data=DATASET.train[block!=i,], 
                 method=&quot;class&quot;, control=rpart.control(cp=0, maxdepth =j)) 
   
   # prédiction 
   pred= predict(treecp,newdata=DATASET.train[block==i,],type=&quot;class&quot;) # prediction sur le bloc
   
   mc&lt;-table(DATASET.train$spam[block==i],pred)
   err[i]=((mc[2,1]+mc[1,2])/sum(mc)) / loss
   
  }
  
  xerror = mean(err, na.rm = T)  
  xstd = sd(err, na.rm = T) / sqrt((length(is.na(err)==F)-1))   
  # print(err) pour control
  res=rbind(res, xerror, xstd)
  
 }
 res=matrix(res, ncol=2, byrow=T)
 data.frame(xerror=res[,1], xstd=res[,2],
            row.names = paste0(&quot;profondeur arbre = &quot;, c(1:j)))
 
 #                      xerror    xstd
 # profondeur arbre = 1 0.5235217 0.01792813
 # profondeur arbre = 2 0.3519275 0.01449117
 # profondeur arbre = 3 0.3004595 0.01427156
 
 # profondeur arbre = 4 0.2474022 0.01145326 =&gt; a comparer avec la ligne correspondant a la taille maximale de arbre0
 
 #   CP          nsplit rel error    xerror       xstd
 # 6 0.01000000  5      0.2514286    0.2685714    0.01399013</code></pre>
<div class="commentaire">
<p>On constate que <code>xerror</code> diminue lorsque l’arbre se complexifie jusqu’à la valeur correspondant à la profondeur de <code>arbre0</code>. A titre de comparaison, nous retrouvons a peu près les valeurs.</p>
</div>
<p><br /></p>
</div>
<div id="variables-dimportance" class="section level4">
<h4>Variables d’importance</h4>
<p>Les variables d’importance correspondent aux variables actives de l’arbre et aux variables surrogate ordonnées par importance. Nous avons deux cas : <br /></p>
<ul>
<li>
Les variables actives ou primary splits, l’importance correspond à la valeur <code>improve</code> du noeud <span class="math inline">\(t\)</span>.
<li>
Pour les surrogate, c’est la valeur de <code>adj</code> multiplié par le <code>improve</code> du primary split pour chaque noeud <span class="math inline">\(t\)</span>.
</ul>
<p>Les variables actives sont celles de l’arbre de sortie (les primaty split) : <br /></p>
<pre class="r"><code>printcp(arbre0)

# Classification tree:
# rpart(formula = DATASET.train$spam ~ ., data = DATASET.train)
# 
# Variables actually used in tree construction:
# [1] capital_run_length_total cf_dollar                cf_exclam                wf_hp                   
# [5] wf_remove               
# 
# Root node error: 1225/3067 = 0.399</code></pre>
<div class="commentaire">
<p>La liste des variables actives par ordre alphabétique: <br /></p>
<p>[1] capital_run_length_total cf_dollar cf_exclam wf_hp<br />
[5] wf_remove</p>
</div>
<p>Vérifications des calculs : <br /></p>
<p>Prenons les 3 premières variables de <code>arbre0$variable.importance</code>. <br /></p>
<pre class="r"><code>arbre0$variable.importance[1:3]</code></pre>
<pre><code>## cf_dollar wf_remove    wf_000 
##  496.6125  210.5973  183.1602</code></pre>
<p>Résumons la sortie <code>arbre0$splits</code> à ces 3 variables. <br /></p>
<pre class="r"><code>arbre0$splits[which(rownames(arbre0$splits) %in% names(arbre0$variable.importance[1:3]))  ,]</code></pre>
<pre><code>##           count ncat     improve  index        adj
## cf_dollar  3067   -1 496.6125453 0.0445 0.00000000
## wf_remove  3067   -1 395.6875398 0.0100 0.00000000
## wf_000        0   -1   0.8311053 0.0450 0.36441718
## wf_remove  2252   -1 210.5972844 0.0600 0.00000000
## wf_000        0   -1   0.9025942 0.6200 0.01970443</code></pre>
<pre class="r"><code># wf_000 est une surrogate qui apparait 2 fois
(0.36441718*496.6125453 ) + (0.01970443*210.5972844 )</code></pre>
<pre><code>## [1] 185.1238</code></pre>
<div class="commentaire">
<p>Pour résumer les variables d’importance sont les valeurs <code>improve</code> des primary split. Pour les surrogate, en cas de répétition, <code>adj</code> est multiplié par <code>improve</code> du primary split et sommé par nombre d’apparition.</p>
</div>
<p><br /></p>
<p><br /></p>
</div>
<div id="cp-optimal-et-elagage" class="section level4">
<h4>CP optimal et élagage</h4>
<p>C’est à partir de la table cp que nous allons déterminer notre arbre optimal. C’est à dire celui qui minimise l’erreur <code>xerror</code> obtenu par validation croisée. <br /></p>
<p>Pour rappel, la table cp : <br /></p>
<pre><code>##           CP nsplit rel error    xerror       xstd
## 1 0.49551020      0 1.0000000 1.0000000 0.02214215
## 2 0.13795918      1 0.5044898 0.5346939 0.01852748
## 3 0.05142857      2 0.3665306 0.4081633 0.01669956
## 4 0.03265306      3 0.3151020 0.3232653 0.01515973
## 5 0.03102041      4 0.2824490 0.3118367 0.01492832
## 6 0.01000000      5 0.2514286 0.2800000 0.01424812</code></pre>
<p>Nous pouvons représenter l’arbre final ainsi que la diminution de <code>xerror</code> pour chaque valeur de <em>cp</em> : <br /></p>
<pre class="r"><code>## représentation graphique de l&#39;arbre 
par(mfrow=c(1,2))
plot(arbre0)
text(arbre0)
plotcp(arbre0, minline = T)</code></pre>
<p><img src="rpart_files/figure-html/unnamed-chunk-20-1.png" width="672" /></p>
<pre class="r"><code># regle 1-se
min(arbre0$cptable[, &quot;xerror&quot;]) + (1*arbre0$cptable[ which.min(arbre0$cptable[, &quot;xerror&quot;]), &quot;xstd&quot;])</code></pre>
<pre><code>## [1] 0.2942481</code></pre>
<div class="commentaire">
<p>Les valeurs de <em>cp</em> prises par défaut ne permettent pas de minimiser ici le critère d’erreur. <br /></p>
<p>La ligne pointillée est calculée avec la règle dite du <span class="math inline">\(&quot;1-SE&quot;\)</span> (règle de l’écart type, Breiman <em>et al</em>, 1984).</p>
</div>
<p>Dans notre cas, l’erreur moyenne par validation croisée <code>xerror</code> diminue mais diminue-t-elle encore ? Pour le savoir, nous avons besoin de générer des arbres plus complexes et donc diminuer la valeur du <em>cp</em>.<br /></p>
<p><b><u>Nouvel arbre :</u></b></p>
<p>Nous avons besoin de construire un nouvelle arbre plus complexe que celui avec la valeur <em>cp</em> par défaut. <br /></p>
<pre class="r"><code>set.seed(1024)
arbre1 =  rpart(DATASET.train$spam~.,data=DATASET.train, 
                control = rpart.control(cp = 0.001)) 
# graphique
par(mfrow=c(1,2))
plot(arbre1)
text(arbre1,pretty=0)
plotcp(arbre1, minline = T)</code></pre>
<p><img src="rpart_files/figure-html/unnamed-chunk-21-1.png" width="672" /></p>
<p>Nous appliquons la règle de l’écart type (“1-SE”) pour choisir un <em>cp</em> inférieur mais aussi l’arbre le plus petit. <br /></p>
<pre class="r"><code># 1-se
se = min(arbre1$cptable[, &quot;xerror&quot;]) + (1*arbre1$cptable[ which.min(arbre1$cptable[, &quot;xerror&quot;]), &quot;xstd&quot;])
arbre1$cptable</code></pre>
<pre><code>##             CP nsplit rel error    xerror       xstd
## 1  0.495510204      0 1.0000000 1.0000000 0.02214215
## 2  0.137959184      1 0.5044898 0.5346939 0.01852748
## 3  0.051428571      2 0.3665306 0.4081633 0.01669956
## 4  0.032653061      3 0.3151020 0.3232653 0.01515973
## 5  0.031020408      4 0.2824490 0.3118367 0.01492832
## 6  0.009795918      5 0.2514286 0.2800000 0.01424812
## 7  0.008979592      6 0.2416327 0.2661224 0.01393382
## 8  0.006530612      8 0.2236735 0.2628571 0.01385818
## 9  0.006122449     12 0.1975510 0.2457143 0.01344982
## 10 0.004489796     14 0.1853061 0.2432653 0.01338988
## 11 0.004081633     16 0.1763265 0.2432653 0.01338988
## 12 0.002993197     18 0.1681633 0.2342857 0.01316650
## 13 0.002040816     21 0.1591837 0.2261224 0.01295833
## 14 0.001632653     23 0.1551020 0.2285714 0.01302131
## 15 0.001469388     28 0.1469388 0.2310204 0.01308383
## 16 0.001224490     33 0.1395918 0.2293878 0.01304220
## 17 0.001000000     35 0.1371429 0.2293878 0.01304220</code></pre>
<pre class="r"><code>#la valeur du 1-se 
se</code></pre>
<pre><code>## [1] 0.2390808</code></pre>
<pre class="r"><code>#selection du plus petit arbre 
arbre1$cptable[arbre1$cptable[,&quot;xerror&quot;]&lt;se , &quot;xerror&quot;]</code></pre>
<pre><code>##        12        13        14        15        16        17 
## 0.2342857 0.2261224 0.2285714 0.2310204 0.2293878 0.2293878</code></pre>
<div class="commentaire">
<p>L’arbre minimal avec l’erreur la plus petite est atteint avec un <em>cp</em> de 0.002993197 (ligne 12 de la table cp) et avec une taille de 18 noeuds.</p>
</div>
<p>Nous allons construire l’arbre optimal et nous pouvons maintenant tester et comparer les performances des modèles <code>arbre0</code>, <code>arbre1</code> et <code>arbre1.prune</code> sur un échantillon test. <br /></p>
<pre class="r"><code>arbre1.prune = prune(arbre1, cp=0.002993197)

plot(arbre1.prune)
title(main=paste0(&quot;Arbre élagué &quot;,&quot;cp = &quot;, &quot;0.002993197&quot;), cex.main = 0.8, outer=F)
text(arbre1.prune,pretty=0)</code></pre>
<p><img src="rpart_files/figure-html/unnamed-chunk-23-1.png" width="672" /></p>
</div>
</div>
<div id="application-sur-echantillon-test" class="section level3">
<h3>Application sur échantillon test</h3>
<p>Nous allons maintenant appliquer aux trois modèles un échantillon test. <br /></p>
<p>Les trois modèles : <br /></p>
<ul>
<li>
<code>arbre0</code> : arbre construit avec les paramètres par défaut.
<li>
<code>arbre1</code> : arbre construit avec un cp arbitrairement plus faible (cp=0.001).
<li>
<code>arbre1.prune</code> : arbre élagué construit à partir de <code>arbre1</code>.
</ul>
<pre class="r"><code>#####
# Echantillon test 
#####

# arbre0 
 #prédiction sur l&#39;échantillon train.
  pred &lt;- predict(arbre0,newdata=DATASET.test,type=&quot;class&quot;)
 
 #matrice de confusion
  mc &lt;- addmargins(table(DATASET.test$spam,pred))
  
 #taux d&#39;erreur
  erreur0 &lt;- (mc[2,1]+mc[1,2])/mc[3,3] # pourcentage total de m.c 
  
 # arbre1 
  #prédiction sur l&#39;échantillon train.
  pred &lt;- predict(arbre1,newdata=DATASET.test,type=&quot;class&quot;)
  
  #matrice de confusion
  mc &lt;- addmargins(table(DATASET.test$spam,pred))
  
  #taux d&#39;erreur
  erreur1 &lt;- (mc[2,1]+mc[1,2])/mc[3,3] # pourcentage total de m.c 
  
   
 # arbre1.prune
  #prédiction sur l&#39;échantillon train.
  pred &lt;- predict(arbre1.prune,newdata=DATASET.test,type=&quot;class&quot;)
  
  #matrice de confusion
  mc &lt;- addmargins(table(DATASET.test$spam,pred))
  
  #taux d&#39;erreur
  erreur1.prune &lt;- (mc[2,1]+mc[1,2])/mc[3,3] # pourcentage total de m.c 
  
 # résultats 
  data.frame(arbre0=erreur0, arbre1=erreur1, arbre1.prune=erreur1.prune)
  
 #   arbre0    arbre1     arbre1.prune
 #   0.1043025 0.0821382  0.0958279</code></pre>
<div class="commentaire">
<p>Sur ce jeu de données “test”, nous abtenons des taux d’erreur (taux de resubstitution) : <br /></p>
<ul>
<li>
<code>arbre0</code> : 10%.
<li>
<code>arbre1</code> : 8.2%.
<li>
<code>arbre1.prune</code> : 9.5%.
</ul>
</div>
<p>Les résultats sont obtenus sur un seul échantillon et nous pouvons <em>“boostraper”</em> l’échantillon test afin de mettre en évidence le biais . <br /></p>
<p><b><u>Boostrap sur échantillon test :</u></b></p>
<pre class="r"><code>######
# BOOTSRAP TEST
######
 

# une fonction permettant de renvoyer le taux d&#39;erreur
 
 #data test, vecteur index aleatoire, modele
 err.boot=function(data, index, modele){ 
  n = dim(data)[1]
  ech.tst = data[index[1:n], ] #sous échantillon
  pred.tst = predict(modele, newdata=ech.tst, type=&quot;class&quot;)
  mc &lt;- table(ech.tst$spam, pred.tst)
  err &lt;- (mc[2,1]+mc[1,2])/sum(mc) # pourcentage total de m.c 
  return(err)
 }
 
 #test fonction
 m=dim(DATASET.test)[1]
 #set.seed(50)
 ind=sample(1:m, replace = T)
 
 err.boot(DATASET.test, ind, arbre0)

 library(boot)
 
 # arbre0
 set.seed(50)
 arbre0.boot = boot(DATASET.test, err.boot, modele=arbre0, R=200)
 
 print(arbre0.boot)

 
#  ORDINARY NONPARAMETRIC BOOTSTRAP
# 
# Call:
# boot(data = DATASET.test, statistic = err.boot, R = 200, modele = arbre0)
# 
# 
# Bootstrap Statistics :
#      original       bias    std. error
# t1* 0.1043025 0.0001205997 0.008020043</code></pre>
<div class="commentaire">
<p>Le <em>bootstrap</em> permet de constater le biais sur l’échantillon test de notre taux d’erreur. Ici nous avons un biais faible et nous pouvons déduire une estimation sans biais du taux d’erreur. <br /></p>
<p><code>2*arbre0.boot$t0 - mean(arbre0.boot$t)</code> # 0.1041819 estimation non biaisée.</p>
</div>
<p><br /></p>
</div>
<div id="comportement-moyen" class="section level3">
<h3>Comportement moyen</h3>
<p>L’objectif de cette partie est d’observer comment des arbres de complexité différentes se comportent. Nous allons générer un nouveau train/test de façon aléatoire et éxecuter les prédictions pour 4 types d’arbre : <br /></p>
<ul>
<li>
Un arbre avec paramètre par défaut (cp=0.001).
<li>
Un arbre avec un cp arbitraire(cp=0.0001).
<li>
Un arbre élagué à partir de l’arbre arbitraire.
<li>
Un arbre maximal (cp=0).
</ul>
<pre class="r"><code>#######
# Comportement moyen de différents arbres 
#######
 
 #init
 err.defaut=c();err.arbi=c();err.prune=c();err.max=c()
 
 ######
 ####BOUCLAGE
 ######
 
 for(i in 1:100){
  #initialisation du seed 
  set.seed(1423+i)
  
  #generation de l&#39;echantillon TRAIN
  #rappel proportion au global &quot;email 61%&quot; &quot;spam 39%&quot;
  
  trainIndex &lt;- sample(index, trunc(length(index) * 0.666666666666667)) 
  DATASET.train &lt;- Don_spam[trainIndex, ]
  
  #proportion de spam % 
  res.prop.train.spam[i] =  round( (length(DATASET.train$spam[which(DATASET.train$spam==1)]) /nrow(DATASET.train)) * 100,2)
  
  #generation de l&#39;echantillon TEST
  DATASET.test &lt;- Don_spam[-trainIndex, ]
  res.prop.test.spam[i] =  round( (length(DATASET.test$spam[which(DATASET.test$spam==1)]) /nrow(DATASET.test)) * 100,2)
  
  library(rpart)
  ######
  # arbre par defaut
  ######
  arb.defaut = rpart(DATASET.train$spam ~ ., DATASET.train)
  
  pred.defaut = predict(arb.defaut, newdata=DATASET.test, type=&quot;class&quot;)
  
  mc &lt;- table(DATASET.test$spam, pred.defaut)
  err.defaut[i] &lt;- (mc[2,1]+mc[1,2])/sum(mc) # pourcentage total de m.c  
  
  
  ######
  # arbre cp arbitraire cp=0.001
  ######
  arb.arbi = rpart(DATASET.train$spam ~ ., DATASET.train,
                   control=rpart.control(cp=0.001))
  
  pred.arbi = predict(arb.arbi, newdata=DATASET.test, type=&quot;class&quot;)
  
  mc &lt;- table(DATASET.test$spam, pred.arbi)
  err.arbi[i] &lt;- (mc[2,1]+mc[1,2])/sum(mc) # pourcentage total de m.c  
  
  
  ######
  # arbre prune
  ######
  # regle du &quot;1- se&quot;
  se=min(arb.arbi$cptable[, &quot;xerror&quot;]) + (1*arb.arbi$cptable[ which.min(arb.arbi$cptable[, &quot;xerror&quot;]), &quot;xstd&quot;])
  #selection du plus petit arbre 
  cp.ind = arb.arbi$cptable[arb.arbi$cptable[,&quot;xerror&quot;]&lt;se , &quot;xerror&quot;][1]
  
  cp.ind= as.integer(names(cp.ind))
  cp.prune = arb.arbi$cptable[cp.ind,&quot;CP&quot;]
  
  #arbre optimal
  arb.prune = prune(arb.arbi, cp=cp.prune)
  pred.prune = predict(arb.prune, newdata=DATASET.test, type=&quot;class&quot;)
  
  mc &lt;- table(DATASET.test$spam, pred.prune)
  err.prune[i] &lt;- (mc[2,1]+mc[1,2])/sum(mc) # pourcentage total de m.c  
  
  
  ######
  # arbre max
  ######
  arb.max = rpart(DATASET.train$spam ~ ., DATASET.train,
                  control=rpart.control(cp=0))
  
  pred.max = predict(arb.max, newdata=DATASET.test, type=&quot;class&quot;)
  
  mc &lt;- table(DATASET.test$spam, pred.max)
  err.max[i] &lt;- (mc[2,1]+mc[1,2])/sum(mc) # pourcentage total de m.c  
  
 } 
 
 mat = rbind(summary(err.defaut, digits = 4),
       summary(err.arbi, digits = 4),
       summary(err.prune, digits = 4),
       summary(err.max, digits = 4)
       )
 row.names(mat) = c(&quot;arbre défaut&quot;, &quot;arbre cp arbitraire&quot;, &quot;arbre prune&quot;, &quot;arbre max&quot;)
 
 #                        Min. 1st Qu.  Median    Mean 3rd Qu.   Max.
 # arbre défaut        0.08475 0.10100 0.10500 0.10610 0.11080 0.1291
 # arbre cp arbitraire 0.06323 0.08149 0.08703 0.08700 0.09322 0.1095
 # arbre prune         0.07301 0.08589 0.09126 0.09174 0.09844 0.1115
 # arbre max           0.06323 0.08409 0.08963 0.08968 0.09550 0.1134</code></pre>
<div class="commentaire">
<p>On constate que en moyenne le taux d’erreur de substitution est proportionnel à la complexité de l’arbre. Sur ces données, l’arbre maximum (risque de surapprentissage ) donne de bons résultats. D’ailleurs si l’on regardait le <code>xerror</code> de l’arbre maximal, on voit que l’erreur se stabilise en fonction de la complexité et ne remonte pas. <br /></p>
<p>Concernant l’arbre élagué, il est moins complexe et fournit des résultats en moyenne légèrement moins bon que l’arbre avec cp arbitraire ou l’arbre maximal. Cependant, il est moins complexe et donc plus stable en théorie. <br /></p>
<p>J’ai également essayé de générer des arbres maximals encore plus sujet au surapprentissage avec le paramètre <code>minbucket = 1</code>. Je ne constate pas sur ces données de cas de “décrochage” (taux d’erreur important) pour un arbre maximal. <br /></p>
<p>J’en conclu une remarque et également une question : <br /></p>
<p>Peut-on en conclure que les arbres de classifications CART ne sont pas sujet au surapprentissage ?</p>
</div>
<p><br /></p>
</div>
<div id="stabilite-importance-des-variables" class="section level3">
<h3>Stabilité, importance des variables</h3>
<p>A travers mes recherches sur <em>CART</em>, j’ai pu lire que les arbres sont sujet à des perturbations et qu’ils ont une certaine variance ou instabilisté. Preuve à l’appui, des études empiriques (Breiman 1996a et Ghattas 1999b) ont montré que les arbres sont instables suite à des perturbations de données. <br /></p>
<p>L’algorithme <em>CART</em> à travers <em>rpart</em> fournit une liste de variables d’importance. Nous avons vu dans une partie précedente le détail de calcul de l’importance d’une variable. Une méthode de mise en évidence de cette instailité est proposé dans Ghattas 1999b. <br /></p>
<p>La méthode est de construire par bootstrap des éhantillons train et d’analyser les valeurs des variables d’importance. Pour rappel <em>rpart</em> nous fournit un vecteur d’importance des variables <code>arbre0$variable.importance</code>. <br /></p>
<p>Dans cette partie, nous allons bootsraper l’échantillon train de départ <code>DATASET.train</code>, visualiser les valeurs et agréger les variables pour fournir un score de 1 à 100. Pour cet exemple, nous allons utiliser le modèle par défaut (avec les paramètres par défaut de <em>rpart</em>)<br /></p>
<pre class="r"><code> ########
 # Stabilité variable importance par bootstrap
 ########
 

 ## Bootstrap du train à partir de DATASET.train
 
 index &lt;- 1:nrow(DATASET.train)
 
 # bootstrap du train sur modèle arbre1.prune 
 res=list();longueur.list=c()
 iteration=40
 
 for(i in 1:iteration){
  #initialisation du seed 
  set.seed(1423+i)
  boot.index &lt;- sample(index, replace = T) 
  train.boot &lt;- DATASET.train[boot.index, ]
  
  ######
  # arbre par defaut
  ######
  arb.defaut = rpart(train.boot$spam ~ ., train.boot)
  imp.defaut = arb.defaut$variable.importance
  
  #stocker la liste des variales d&#39;importance
  res[[i]] = imp.defaut

 }
 # res # list des variables d&#39;importance
 
 #les noms des var sans doublon 
 list.nom.var = unique(names(unlist(res)))
 
 
 # INIT : data frame initial 
 t=data.frame(row.names =list.nom.var)
 
 # constrution du data frame terme à terme 
 for(i in 1:iteration){
  var = res[[i]]
  var.name = names(var)
  sum.var = sum(var)
  
  for(j in 1:length(var)){
    var[j] = (var[j]/sum.var)*100
   for(k in 1:length(list.nom.var)){
    if(var.name[j]==list.nom.var[k]) t[k,paste0(&quot;iter&quot;,i)]=var[j] 
   }
  }
 }
 
 ### Agregation par ligne 
 
 t[, &quot;somme ligne&quot;]=rowSums(t, na.rm = T)  # la matrice rapporté sur 100 par coclonne (itération)
 
 ### boxplot des variables d&#39;importances normalisé (normalisé %)
 boxplot(t(t[,1:iteration]), las=2) # libelé vertical
 
 ### affichage plus compact
 summary(t[,iteration+1])
 boxplot(t(t[ t[,iteration+1]&gt;10  ,1:iteration]), las=2) # &gt;10% pour chaque variable 
 
 ### tableau final agrégation des variables d&#39;importance pour n itérations 
 
 tab.final = prop.table(t[, &quot;somme ligne&quot;]) * 100 
 
 # tri par ordre d&#39;importance
  # test est une variable bidon pour avec 2 colonnes ce qui garde les noms de ligne sinon vecteur
 tab.final = data.frame(tab.final, &quot;test&quot;) ; row.names(tab.final) = row.names(t)  
  colnames(tab.final)=&quot;importance&quot;

 tab.final = tab.final[order(tab.final$importance, decreasing = T),]
 
 x=data.frame(tab.final[,1]) ; row.names(x) = row.names(tab.final) ; colnames(x)=&quot;importance&quot; ; x
 
 # importance &gt; 0.5 ~= 1% sur 40 bootstrap
 
 #                            importance
 # cf_dollar                  20.899146637
 # cf_exclam                  12.459647639
 # wf_remove                  10.072738880
 # capital_run_length_longest  7.744706579
 # wf_000                      6.487406449
 # wf_money                    6.442727300
 # wf_free                     4.390655376
 # capital_run_length_average  4.107701624
 # wf_your                     4.023678107
 # capital_run_length_total    3.896851914
 # wf_hp                       3.112132471
 # wf_receive                  2.498001148
 # wf_credit                   1.854512702
 # wf_you                      1.467290925
 # wf_hpl                      1.372379042
 # wf_order                    1.327879981
 # wf_all                      1.098003360
 # wf_george                   0.936810007
 # wf_650                      0.602349253
 # wf_business                 0.601667733</code></pre>
<p><br /></p>
<p><b><u>Boxplot des variables d’importances par bootstrap :</u></b> <img src="include/boxplot_importance.png" /> <br /> <br /></p>
<p><b><u>Hiérarchie des variables d’importances par bootstrap :</u></b> <img src="include/hierarchie_importance.png" /></p>
<div class="commentaire">
<p>A travers le boxplot, nous avons un aperçu des variables d’importance. <br /><br />
Enfin, nous pouvons déduire une hiérarchie normalisée de toutes les variables d’importance.</p>
</div>
</div>
</div>



</div>
</div>

</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.header').parent('thead').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open')
  });
});
</script>

<!-- code folding -->

<script>
$(document).ready(function ()  {

    // move toc-ignore selectors from section div to header
    $('div.section.toc-ignore')
        .removeClass('toc-ignore')
        .children('h1,h2,h3,h4,h5').addClass('toc-ignore');

    // establish options
    var options = {
      selectors: "h1,h2,h3,h4",
      theme: "bootstrap3",
      context: '.toc-content',
      hashGenerator: function (text) {
        return text.replace(/[.\\/?&!#<>]/g, '').replace(/\s/g, '_').toLowerCase();
      },
      ignoreSelector: ".toc-ignore",
      scrollTo: 0
    };
    options.showAndHide = false;
    options.smoothScroll = false;

    // tocify
    var toc = $("#TOC").tocify(options).data("toc-tocify");
});
</script>

<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
